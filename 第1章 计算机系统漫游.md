# 第1章 计算机系统漫游

**计算机系统** 是由 **硬件** 和 **系统软件** 组成的，它们共同工作来运行应用程序。

```C++
// hello.c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```

我们将通过跟踪 `hello` 程序的生命周期来开始对系统的学习。

## 1.1 信息就是位 + 上下文

`hello` 程序的生命周期是从一个 **源程序（或者说源文件）** 开始的，即程序员通过编辑器创建并保存的 **文本文件** 。源程序实际上就是一个 **由值 `0` 和 `1` 组成的 <u>位</u> 序列， `8` 个位被组织成一组，称为 <u>字节</u> 。每个字节表示程序中的某些文本字符** 。

`hello.c` 程序是以字节序列的方式存储在文件中的。每个字节都有一个整数值，对应某些字符。

像 `hello.c` 这样只由 `ASCII` 字符构成的文件称为 **文本文件** ，所有其他文件都称为 **二进制文件** 。

**系统中的所有信息 - 包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络数据，全部都是由一串位表示的** 。区分不同数据对象的唯一方法是我们读到这些数据对象时的 **上下文** 。

「数字的机器表示方式」和「实际的整数以及实数」是 **不同的** 。机器的「存储值」是对「真值」的 **有限近似** ，有时候会有意想不到的行为。

## 1.2 程序被其他程序翻译成不同的格式

为了能运行 `hello.c` 程序，每条 C 语句都必须被其他程序转化成一系列的低级 **机器语言** 指令。然后这些指令按照一种称为 **可执行目标程序** 的格式打好包，并以二进制磁盘文件的形式存储起来。目标程序也被称为 **可执行目标文件** 。

在 `Unix` 系统上从源文件到目标文件的转化是由 **编译器驱动程序** 完成的。这个翻译过程可以分为 **四个阶段** 完成：**预处理、编译、汇编 和 链接**。预处理器、编译器、汇编器 和 链接器 一起构成了 **编译系统** 。

1. **预处理阶段** ：预处理器 根据以字符 `#` 开头的命令，修改源文件。结果就得到了另一个 C 程序，通常以 `.i` 作为文件扩展名。
2. **编译阶段** ：编译器 将 **文本文件 `hello.i`** 翻译成 **文本文件 `hello.s`** 。该文本文件是一个 **汇编语言程序** 。汇编语言为 **不同高级语言的不同编译器提供了通用的输出语言** 。
3. **汇编阶段** ：汇编器 将 `hello.s` 翻译成机器语言指令。并把这些指令打包成一种叫做 **可重定位目标程序** 的格式，生成 `hello.o` 文件，该文件是一个 **二进制文件** 。
4. **链接阶段** ：链接器 将 一些库中的函数文件比方说  `printf.o` 以某种方式合并到 `hello.o` 文件中，结果就得到了 `hello` 文件，这是一个 **可执行文件** ，可以被加载到内存中然后执行。

## 1.3 了解编译系统如何工作是大有益处的

* 优化程序性能。
* 理解链接时出现的错误。
* 避免安全漏洞。

## 1.4 处理器读并解释存储在内存中的指令

`hello` 文件在 `Shell` 中的执行方式：

```Shell
linux> ./hello
hello, world
linux>
```

`Shell` 是一个 **命令行解释器** 。它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 `shell` 指令，那么 `shell` 就会假设这是一个可执行文件的名字，然后尝试加载并且运行这个程序。

### 1.4.1 系统的硬件组成

1. **总线** ：贯穿整个系统的一组电子管道，携带信息字节并负责在各个部件之间进行传递。通常总线被设计成传送 **定长的字节块** 。也就是 **字** 。字中的字节数称为 **字长** ，是一个系统的基本参数。现在绝大多数 **机器字长** 要么是 `4` 个字节，要么是 `8` 个字节。
2. **I/O设备** ：I/O 设备是 **系统与外部世界的联系通道** 。每个 I/O 设备都通过一个「控制器」或者「适配器」与「I/O 总线」相连。这两者的区别主要在封装方式上。
3. **主存** ：主存是一个临时存储设备，在处理器运行程序时，用来存放程序和数据。从物理上来说，主存是由一组 **动态随机存储器（ DRAM ）芯片** 组成的；从逻辑上来说，存储器是一个线性的字节数组，每个字节都有唯一的 **地址** 。这些地址是从零开始的。
4. **处理器** ：是解释或者执行存储在主存上的指令的引擎。处理器的核心是一个 **大小为一个字的存储设备（寄存器），称为程序计数器（ PC ）** 。任何时刻 PC 都指向主存中的某条机器语言指令（指令的地址）。

由 **指令集架构** 决定，处理器从 **程序计数器** 指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新 PC ，使其指向下一条指令……

这样的简单操作围绕着 **主存、寄存器文件（ register file ） 和 算术逻辑单元（ ALU ）** 进行。 **寄存器文件** 是一个小存储设备 ，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU 计算新的数据和地址。

#### CPU 可能的核心操作

* **加载** ：从主存复制一个字节或者一个字到寄存器。
* **存储** ：从寄存器复制一个字节或者一个字到主存。
* **操作** ：把两个寄存器的内容复制到 ALU ， ALU 对这两个字做算术运算，并将结果放在另一个寄存器中。
* **跳转** ：从指令本身抽取一个字，并将这个字复制到 PC 中。

**指令集架构** 描述的是每条机器代码指令的效果。**微体系结构** 描述的是处理器实际上是如何实现的。

### 1.4.2 运行 `hello` 程序

初始时，`Shell` 等待输入的命令。当在键盘上输入字符串 `./hello` 之后，`Shell` 程序将字符逐一读入寄存器，再把它放到内存中。

当在键盘上按下 `Enter` 键的时候，`Shell` 程序就开始执行指令来加载 `hello` 文件。指令将文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 `hello, world\n` 。

当目标文件被加载到主存之后，处理器就开始执行程序中的 `main` 函数中的机器语言指令。字符串 `hello, world\n` 将被从 **主存** 复制到 **寄存器文件** ，然后再从 **寄存器文件** 中复制到 **显示设备** ，最终显示在屏幕上。

## 1.5 高速缓存至关重要

以上步骤说明 **系统花费了大量时间把信息从一个地方复制到另一个地方** 。因此，系统设计者的一个主要目标就是 **使这些移动操作能尽快的完成** 。

较大的存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备。

一个典型的 **寄存器文件** 只能存储几百字节的信息。

系统设计者采用了更小更快的设备，称为 **高速缓存存储器（简称为 Cache 或者 高速缓存）** ，作为暂时的集结区域，存放处理器近期可能需要的信息。

L1 和 L2 高速缓存使用一种叫做 **静态随机访问存储器** 的硬件技术实现的。并且利用了高速缓存的 **局部性** 原理，即程序具有访问局部区域里的数据和代码的趋势。

**<u>意识到高速缓存存储器存在的程序员能够利用高速缓存将程序的性能提高一个数量级</u>** 。

## 1.6 存储设备形成层次结构

在这个层次结构中，从上到下，设备的访问速度越来越慢，容量也越来越大，并且每个字节的造价也更便宜。

**存储器层次结构** 的主要思想是 **上一层的存储器作为低一层存储器的高速缓存** 。

## 1.7 操作系统管理硬件

应用程序依靠 **操作系统** 提供的服务。操作系统是 **应用程序和硬件之间的一层软件** 。所有应用程序对硬件的操作尝试都必须通过操作系统。

操作系统的两个基本功能：

* **防止硬件被失控的应用程序滥用** 。
* **向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备** 。

**文件** 是对 I/O 设备的抽象表示；**虚拟内存** 是对主存和磁盘的抽象表示；**进程** 则是对处理器、主存、I/O 设备的抽象表示。

### 1.7.1 进程

操作系统提供的假象：程序看上去是独占的使用处理器、主存和 I/O 设备。这些假象就是通过 **进程** 的概念来实现的。

**进程** 是 **操作系统对正在运行的程序的一种抽象** 。而 **并发运行** ，则是说 **一个进程的指令和另一个进程的指令是交错执行的** 。

**一个 CPU 看上去都像是在并发的执行多个进程，这是通过处理器在进程之间来回切换实现的** 。操作系统实现这种交错执行的机制称为 **<u>上下文切换</u>** 。

操作系统保持跟踪进程运行所需要的所有状态信息。这种状态就是所谓的 **上下文** 。操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行 **上下文切换** ： **<u>保存当前进程的上下文，打开新进程的上下文，然后将控制权传递到新进程，此时新进程就会从它上次停下的地方开始执行</u>** 。

从一个进程到另一个进程的切换是由 **操作系统内核** 管理的。

内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。

### 1.7.2 线程

一个进程实际上还可以由多个称为 **线程** 的执行单元组成， **每个线程都运行在进程的上下文中，并共享同样的代码和全局数据** 。

### 1.7.3 虚拟内存

**虚拟内存** 是一个抽象的概念，它为每一个进程提供了一个假象： **每个进程都在独占的使用内存** 。每个进程看到的内存都是一样的，称为 **虚拟地址空间** 。

在 Linux 中，地址空间最上面的区域是 **操作系统代码和数据区域** ，这对所有进程来说都是一样的。地址空间底部区域存放 **用户进程定义的代码和数据** 。

每个进程看到的 **虚拟地址空间** 由大量准确定义的区构成，每个区都有专门的功能。

现在从最低地址开始，逐步向上介绍：

* **程序代码和数据** ：对所有的进程来说，代码是从同一个固定的地址开始的，紧接着的是和 C 全局变量相对应的数据位置。
* **堆** ：代码和数据区在进程一开始运行就被指定了大小。堆可以在运行时动态的扩展和收缩。
* **共享库** ：地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。
* **栈** ：编译器使用栈来实现函数调用。用户栈也会随着函数的调用层级来动态的扩展和收缩。
* **内核虚拟内存** ：地址空间的顶部区域是为内核保留的。应用程序禁止读写这个区域。

虚拟内存运作的基本思想：**把一个进程虚拟内存的内容存储在磁盘上，然后用内存作为磁盘的高速缓存** 。

### 1.7.4 文件

**文件就是字节序列** ，仅此而已。

## 1.8 系统之间利用网络通信

网络可以视为一个 **I/O 设备** 。系统可以通过网络读取其他机器发送来的数据，并把数据复制到自己的主存。

## 1.9 重要主题

**<u>系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的</u>** 。

### 1.9.1 $Amdahl$ 定律

**当我们对系统的某个部分进行加速时，其对系统整体性能的影响取决于该部分的 <u>重要性</u> 和 <u>加速程度</u>** 。

若程序执行的原时间为 $T_{old}$ 。提速部分执行时间占整个程序执行时间的比例为 $\alpha$ 。而提速部分的提升比例为 $k$ 。即该部分的所需的初始时间为 ${\alpha}T_{old}$ 。现在所需的时间为 ${\alpha}T_{old}/k$ 。因此执行总时间应当是：

$$
T_{new} = {\alpha} T_{old} / k + ( 1 - {\alpha}) T_{old}
$$

则可以计算加速比 $S$ 为：

$$
S = T_{old} / T_{new} = \frac{ 1 }{( 1 - {\alpha}) + {\alpha} / k}
$$

**要想显著加速整个系统，必须提升全系统中相当大的部分的速度**。

### 1.9.2 并发和并行

**并发** 是一个通用的概念，指一个同时具有多个活动的系统。

**并行** 指的是用并发来使一个系统运行的更快。

#### 线程级并发

传统意义上，这种并发执行只是模拟出来的，是通过 **使一台计算机在它正在执行的进程间来回切换实现的** 。

多核处理器 是 **将多个 CPU 集成到一个集成电路芯片上实现的** 。

超线程（同时多线程）： **允许一个 CPU 执行多个控制流的技术。常规处理器大约需要 `20,000` 个时钟周期做不同线程之间的切换，而超线程的处理器可以在 `1` 个周期的基础上决定要执行哪一个线程** 。

#### 指令级并行

现代处理器可以 **同时执行多条指令的属性** 称为指令级并行。

流水线：在流水线中， **执行一条指令所需要的活动被划分成不同的步骤，将处理器的硬件组织成一系列不同的阶段，每个阶段执行一个步骤** 。

如果处理器可以达到比一个周期一条指令更快的执行速率，就称为 **超标量处理器** 。

#### 单指令、多数据并行

许多现代处理器拥有特殊的硬件，允许**一条指令产生多个可以并行执行的操作**，这种方式称为单指令、多数据，即 SIMD 并行。

### 1.9.3 计算机系统中抽象的重要性

抽象的使用是计算机科学中最重要的概念之一。

在处理器里，指令集架构提供了对实际处理器硬件的抽象。

虚拟机：它提供对整个计算机的抽象。

## 1.10 小结

