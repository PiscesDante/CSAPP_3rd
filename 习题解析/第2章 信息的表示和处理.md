# 第2章 信息的表示和处理

## 练习题 2.1

完成下面的数字转换：

* 将 `0x39A7F8` 转换为二进制。
* 将二进制 `1100100101111011` 转换为十六进制。
* 将 `0xD5E4C` 转换为二进制。
* 将二进制 `1001101110011110110101` 转换为十六进制。

解答：

使用 辅助程序 文件夹中的 `number_form_converter.hpp` 即可完成相应的转换。

```C++
#include "./number_form_converter.hpp"

int main(int argc, char** argv)
{
    std::cout << hexadecimal_to_binary("0x39A7F8") << std::endl;
    std::cout << binary_to_hexadecimal("1100100101111011") << std::endl;
    std::cout << hexadecimal_to_binary("0xD5E4C") << std::endl;
    std::cout << binary_to_hexadecimal("1001101110011110110101") << std::endl;
    // 001110011010011111111000
    // 0xC97B
    // 11010101111001001100
    // 0x26E7B5
    return 0;
}
```

## 练习题 2.2

填写下表中的空白项，给出 2 的不同次幂的十进制和十六进制的表示：（图表见书）

解答：

```
n     2^n（十进制）   2^n（十六进制）
9     512            0x200
19    [524288]       [0x80000]
[14]  16384          [0x4000]
[16]  [65536]        0x10000
17    [131072]       [0x20000]
[5]   32             [0x20]
[7]   [128]          0x80
```

## 练习题 2.3

> 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制的值：

解答：

```
十进制       二进制          十六进制
0           0000 0000      0x00
167         [1010 0111]    [0xA7]
62          [0011 1110]    [0x3E]
188         [1011 1100]    [0xBC]
[55]        0011 0111      [0x37]
[136]       1000 1000      [0x88]
[82]        [0101 0010]    0x52
[172]       [1010 1100]    0xAC
[231]       [1110 0111]    0xE7
```

## 练习题 2.4

> 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六进制表示。提示：只要将执行十进制加法和减法所使用的方法改成以 `16` 为基数。

解答：

```
A. 0x503C + 0x8 = [0x5044]
B. 0x503C - 0x40 = [0x4FFC]
C. 0x503C + 64 = [0x50A0]
D. 0x50EA - 0x503C = [0x00AE]
```

## 练习题 2.5

> 思考下面对 `show_bytes` 的三次调用：

```C++
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1); /* A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */
```

> 指出在小端法机器和大端法机器上，每次调用的输出值。

解答：

```
分析：
十六进制的 1 位代表二进制的 4 位：
0x87654321 -> 1000 0111 0110 0101 0100 0011 0010 0001
A. 打印 1 个字节 -> 8 位
B. 打印 2 个字节 -> 16 位
C. 打印 3 个字节 -> 24 位

结果：
A. 小端法：[21]       大端法：[87]
B. 小端法：[21 43]    大端法：[87 65]
C. 小端法：[21 43 65] 大端法：[87 65 43]
```

## 练习题 2.6

> 使用 `show_int` 和 `show_float` ，我们确定整数 `3510593` 的十六进制表示为 `0x00359141` ，而浮点数 `3510593.0` 的十六进制表示为 `0x4A564504` 。


> A. 写出这两个十六进制值的二进制表示。

解答：

```
0x00359141 -> 0b 0000 0000 0011 0101 1001 0001 0100 0001
0x4A564504 -> 0b 0100 1010 0101 0110 0100 0101 0000 0100
```

> B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？

解答：

```
00000000001 101011001000101000001
  010010100 101011001000101000001 00 

一共有 21 位匹配
```

> C. 串中的什么部分不相匹配？

解答：

```
串中前面的一部分和后面的一部分不匹配。
```

## 练习题 2.7

> 下面对 `show_bytes` 的调用将输出什么结果？

```C++
const char* s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
// 注意字母 a ~ z 的 ASCII 码为 0x61 ~ 0x7A
```

解答：

```
61 62 63 64 65 66
```

## 练习题 2.8

> 填写下表，给出位向量的布尔运算求值结果。

解答：

```
a = 01101001
b = 01010101
~a = [10010110]
~b = [10101010]
a & b = [01000001]
a | b = [01111101]
a ^ b = [00111100]
```

## 练习题 2.9

通过混合三种不同颜色的光（红色、绿色和蓝色），计算机可以在视频屏幕或者液晶显示器上产生彩色的画面。设想一种简单地方法，使用三种不同颜色的光，每种光都能打开或者关闭，投射到玻璃屏幕上，如图所示。

那么基于光源 `R`（红）、`G`（绿）、`B`（蓝）的关闭（ `0` ）或者打开（ `1` ），我们就能创建 `8` 种不同的颜色。

这些颜色中的每一种都能用一个长度为 `3` 的位向量来表示，我们可以对它们进行布尔运算。

> A. 一种颜色的 补 是通过关掉打开的光源，且打开关掉的光源而形成的。那么上面列出的 `8` 中颜色的每一种的 补 是什么？

解答：

```
~黑色 = 111（白色）
~蓝色 = 110（黄色）
~绿色 = 101（红紫色）
~蓝绿色 = 100（红色）
~红色 = 011（蓝绿色）
~红紫色 = 010（绿色）
~黄色 = 001（蓝色）
~白色 = 000（黑色）
```

> B. 描述下列颜色应用布尔运算的结果：

解答：

```
蓝色 | 绿色 = [011（蓝绿色）]
黄色 & 蓝绿色 = [010（绿色）]
红色 ^ 红紫色 = [001（蓝色）]
```

## 练习题 2.10

> 对于任一位向量 `a` ，有 `a ^ a = 0` 。应用这一属性，考虑下面的程序：

```C++
void inplace_swap(int* x, int* y)
{
    *y = *x ^ *y; /* STEP 1 */
    *x = *x ^ *y; /* STEP 2 */
    *y = *x ^ *y; /* STEP 3 */
}
```

...

> 以指针 `x` 和 `y` 指向的位置存储的值分别是 `a` 和 `b` 作为开始，填写下表，给出在程序的每一步之后，存储在这两个位置中的值。利用 `^` 的属性证明达到了所希望的效果。回想一下，每个元素就是它自身的加法逆元（ `a ^ a = 0` ）

解答：

```
步骤    *x           *y
初始     a            b
1->     a            a ^ b
2->     0 ^ b == b   a ^ b
3->     b            a ^ 0 = a
```

## 练习 2.11

> 在练习题 2.10 中的 `inplace_swap` 函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：

```C++
void reverse_array(int a[], int cnt)
{
    int first, last;
    for (first = 0, last = cnt - 1; first <= last; ++first, ++last) {
        inplace_swap(&a[first], &a[last]);
    }
}
```

> ... 实际上你会发现这段代码对所有偶数长度的数组都能正确的工作，但是当数组的长度为奇数时，它就会把中间的元素设置为 `0` 。

> A. 对于一个长度为奇数的数组，长度 `cnt = 2k + 1` ，函数 `reverse_array` 最后一次循环中，变量 `first` 和 `last` 的值分别是什么？

解答：

```
first == last == (2k + 1) / 2
```

> B. 为什么这时调用函数 `inplace_swap` 会将数组元素设置为 `0` ？

解答：

```
因为两个指针指向了同一个对象，也就是同一个值。

void inplace_swap(int* x, int* y)
{   x 和 y 指向了同一个地址
    *y = *x ^ *y; -> *y == 0 => *x == 0
    ...
}
```

> C. 对 `reverse_array` 的代码做哪些简单改动就能消除这个问题？

解答：

```C++
void reverse_array(int a[], int cnt)
{
    int first, last;
    for (first = 0, last = cnt - 1; first < last; ++first, ++last) {
        inplace_swap(&a[first], &a[last]);
    }
}
```

## 练习题 2.12

> 对于下面的值，写出变量 `x` 的 C 语言表达式。你的代码应该对任何字长 `w >= 8` 的值都能工作。我们给出了当 `x = 0x87654321` 以及 `w = 32` 时表达式求值的结果，仅供参考。

> A. `x` 的最低有效字节，其他位均置为 `0` 。 `[0x00000021]`

解答：

```
0x87654321 & 0x000000FF
```

> B. 除了 `x` 的最低有效字节外，其他的位都取补，最低有效字节保持不变。 `[0x789ABC21]`

解答：

```
0x87654321 ^ 0xFFFFFF00
```

> C. `x` 的最低有效字节全部置 `1` ，其他字节都保持不变。 `[0x876543FF]`

解答：

```
0x87654321 | 0x000000FF
```

## 练习题 2.13

* `bis`（位设置）：输入一个数据字 `x` 和一个掩码字 `m` 。在 `m` 为 `1` 的每个位置上，将 返回值 `z` 对应的位设置为 `1` 。
* `bic`（位清除）：输入一个数据字 `x` 和一个掩码字 `m` 。在 `m` 为 `1` 的每个位置上，将 返回值 `z` 对应的位设置为 `0` 。

为了看清楚这些运算与 C 语言位级运算的关系，假设我们有两个函数 `bis` 和 `bic` 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 `|` 和 `^` 运算。填写下列代码中缺失的代码。提示：写出 `bis` 和 `bic` 运算的 C 语言表达式。

解答：

```C++
/* Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
    int result = [bis(x, y)];
    return result;
}

/* Compute x^y using only calls to functions bis and bic */
/* STAR */ 
int bool_xor(int x, int y) {
    int result = `bis(bic(x, y), bic(y, x))`;
            //    ~~~~~~~~~~~~~~~~~~~~~~~~~ FROM TEXT BOOK ANSWER...
    return result;
}
/* This problem is too difficult to figure out... */ 
```

## 练习题 2.14

> 假设 `x` 和 `y` 的字节值分别为 `0x66` 和 `0x39` 。填写下表，指明各个 C 表达式的字节值。

解答：

```
分析：
 x = 0b 0110 0110
~x = 0b 1001 1001
 y = 0b 0011 1001
~y = 0b 1100 0110
```

```
表达式     值
x & y     0b 0010 0000 -> 0x20
x | y     0b 0111 1111 -> 0x7F
~x | ~y   0b 1101 1111 -> 0xDF
x & !y    0b 0000 0000 -> 0x00

x && y    0b 0000 0001 -> 0x01
x || y    0b 0000 0001 -> 0x01
!x || !y  0b 0000 0000 -> 0x00
x && ~y   0b 0000 0001 -> 0x01
```

## 练习题 2.15

只使用位级和逻辑运算，编写一个 C 表达式，它等价于 `x == y` 。换句话说，当 `x` 和 `y` 相等时它将返回 `1` ，否则就返回 `0` 。

解答：

```
!(x ^ y)

解释：
已知 a ^ a == 0，那么
若 x ^ y == 0 则 x == y
若 x ^ y != 0 则 x != y
C 语言中非零值将会自动的转换成 true
```

## 练习题 2.16

> 填写下表，展示不同位移运算对单字节数的影响。思考位移运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行位移运算，然后再转换回十六进制。每个答案都应该是 8 个二进制数字或者 2 个十六进制数字。

解答：

```
x
十六进制    二进制
0xC3       11000011
0x75       01110101
0x87       10000111
0x66       01100110
```

```
x << 3
二进制        十六进制
00011000     0x18
10101000     0xA8
00111000     0x38
00110000     0x30
```

```
x >> 2（逻辑的）
二进制        十六进制
00110000     0x30
00011101     0x1D
00100001     0x21
00011001     0x19
```

```
x >> 2（算术的）
二进制        十六进制
11110000     0xF0
00011101     0x1D
11100001     0xE1
00011001     0x19
```

## 练习题 2.17

> 假设 `w = 4` ，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出等式（2.1）和等式（2.3）所示的求和公式中的 2 的非零次幂，填写下表：

解答：

```

(x)十六进制 (x)二进制    B2U(x)                      B2T(x)
0xE        [1110]      [2^3 + 2^2 + 2^1 = 14]     [-2^3 + 2^2 + 2^1 = -2]
0x0        0000        0                           0
0x5        0101        2^2 + 2^0 = 5               2^2 + 2^0 = 5
0x8        1000        2^3 = 8                     -2^3 = -8
0xD        1101        2^3 + 2^2 + 2^0 = 13        -2^3 + 2^2 + 2^0 = -3
0xF        1111        2^3 + 2^2 + 2^1 + 2^0 = 15  -2^3 + 2^2 + 2^1 + 2^0 = -1
```

## 练习题 2.18

> 在下面的列表中，对于标号为 A ~ I（标记在）的那行，将指令名（ `sub` 、`mov` 和 `add` ）右边显示的（32 位补码形式表示的）十六进制值转换为等价的十进制值。

解答：

```
sub $0x2e0 %rsp A. 226
mov -0x58 ...   B. -133
add 0x28  ...   C. 130
mov -0x30 ...   D. -48
mov 0x78  ...   E. 120
mov 0x88  ...   F. 136
mov 0x1f8 ...   G. 520
mov 0xc0  ...   H. 192
mov -0x48 ...   I. -72
```

## 练习题 2.19

> 利用你解答练习题 2.17 时填写的表格，填写下列描述函数 `T2U` 的表格。

解答：

```
x    T2U（补码形式当作源码来解读）
-8   1111 1000 -> 8
-3   1111 1101 -> 13
-2   1111 1110 -> 14
-1   1111 1111 -> 15
0    0000 0000 -> 0
5    0000 0110 -> 5
```

## 练习题 2.20

> 请说明等式（2.5）是如何应用到解答练习题 2.19 时生成的表格中的各项的。

解答：

当 `x >= 0` 时，位模式的解释出来的值不变；当 `x < 0` 时，位模式解释出来的值就会发生环绕，就是 2 的 当前位模式最大长度 的次方加上当前 `x` 的值。

## 练习题 2.21

> 假设在采用补码运算的 32 位机器上对这些表达式求值，按照图 2-19 格式填写下表，描述强制类型转换和运算关系的结果。

解答：

```
类型        求值
无符号      1
无符号      0
无符号      0
有符号      
有符号
```