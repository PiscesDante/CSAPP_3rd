# 第2章 信息的表示和处理

## 练习题 2.1

完成下面的数字转换：

* 将 `0x39A7F8` 转换为二进制。
* 将二进制 `1100100101111011` 转换为十六进制。
* 将 `0xD5E4C` 转换为二进制。
* 将二进制 `1001101110011110110101` 转换为十六进制。

解答：

使用 辅助程序 文件夹中的 `number_form_converter.hpp` 即可完成相应的转换。

```C++
#include "./number_form_converter.hpp"

int main(int argc, char** argv)
{
    std::cout << hexadecimal_to_binary("0x39A7F8") << std::endl;
    std::cout << binary_to_hexadecimal("1100100101111011") << std::endl;
    std::cout << hexadecimal_to_binary("0xD5E4C") << std::endl;
    std::cout << binary_to_hexadecimal("1001101110011110110101") << std::endl;
    // 001110011010011111111000
    // 0xC97B
    // 11010101111001001100
    // 0x26E7B5
    return 0;
}
```

## 练习题 2.2

填写下表中的空白项，给出 2 的不同次幂的十进制和十六进制的表示：（图表见书）

解答：

```
n     2^n（十进制）   2^n（十六进制）
9     512            0x200
19    [524288]       [0x80000]
[14]  16384          [0x4000]
[16]  [65536]        0x10000
17    [131072]       [0x20000]
[5]   32             [0x20]
[7]   [128]          0x80
```

## 练习题 2.3

> 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制的值：

解答：

```
十进制       二进制          十六进制
0           0000 0000      0x00
167         [1010 0111]    [0xA7]
62          [0011 1110]    [0x3E]
188         [1011 1100]    [0xBC]
[55]        0011 0111      [0x37]
[136]       1000 1000      [0x88]
[82]        [0101 0010]    0x52
[172]       [1010 1100]    0xAC
[231]       [1110 0111]    0xE7
```

## 练习题 2.4

> 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六进制表示。提示：只要将执行十进制加法和减法所使用的方法改成以 `16` 为基数。

解答：

```
A. 0x503C + 0x8 = [0x5044]
B. 0x503C - 0x40 = [0x4FFC]
C. 0x503C + 64 = [0x50A0]
D. 0x50EA - 0x503C = [0x00AE]
```

## 练习题 2.5

> 思考下面对 `show_bytes` 的三次调用：

```C++
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1); /* A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */
```

> 指出在小端法机器和大端法机器上，每次调用的输出值。

解答：

```
分析：
十六进制的 1 位代表二进制的 4 位：
0x87654321 -> 1000 0111 0110 0101 0100 0011 0010 0001
A. 打印 1 个字节 -> 8 位
B. 打印 2 个字节 -> 16 位
C. 打印 3 个字节 -> 24 位

结果：
A. 小端法：[21]       大端法：[87]
B. 小端法：[21 43]    大端法：[87 65]
C. 小端法：[21 43 65] 大端法：[87 65 43]
```

## 练习题 2.6

> 使用 `show_int` 和 `show_float` ，我们确定整数 `3510593` 的十六进制表示为 `0x00359141` ，而浮点数 `3510593.0` 的十六进制表示为 `0x4A564504` 。


> A. 写出这两个十六进制值的二进制表示。

解答：

```
0x00359141 -> 0b 0000 0000 0011 0101 1001 0001 0100 0001
0x4A564504 -> 0b 0100 1010 0101 0110 0100 0101 0000 0100
```

> B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？

解答：

```
00000000001 101011001000101000001
  010010100 101011001000101000001 00 

一共有 21 位匹配
```

> C. 串中的什么部分不相匹配？

解答：

```
串中前面的一部分和后面的一部分不匹配。
```

## 练习题 2.7

> 下面对 `show_bytes` 的调用将输出什么结果？

```C++
const char* s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
// 注意字母 a ~ z 的 ASCII 码为 0x61 ~ 0x7A
```

解答：

```
61 62 63 64 65 66
```

## 练习题 2.8

> 填写下表，给出位向量的布尔运算求值结果。

解答：

```
a = 01101001
b = 01010101
~a = [10010110]
~b = [10101010]
a & b = [01000001]
a | b = [01111101]
a ^ b = [00111100]
```

## 练习题 2.9

通过混合三种不同颜色的光（红色、绿色和蓝色），计算机可以在视频屏幕或者液晶显示器上产生彩色的画面。设想一种简单地方法，使用三种不同颜色的光，每种光都能打开或者关闭，投射到玻璃屏幕上，如图所示。

那么基于光源 `R`（红）、`G`（绿）、`B`（蓝）的关闭（ `0` ）或者打开（ `1` ），我们就能创建 `8` 种不同的颜色。

这些颜色中的每一种都能用一个长度为 `3` 的位向量来表示，我们可以对它们进行布尔运算。

> A. 一种颜色的 补 是通过关掉打开的光源，且打开关掉的光源而形成的。那么上面列出的 `8` 中颜色的每一种的 补 是什么？

解答：

```
~黑色 = 111（白色）
~蓝色 = 110（黄色）
~绿色 = 101（红紫色）
~蓝绿色 = 100（红色）
~红色 = 011（蓝绿色）
~红紫色 = 010（绿色）
~黄色 = 001（蓝色）
~白色 = 000（黑色）
```

> B. 描述下列颜色应用布尔运算的结果：

解答：

```
蓝色 | 绿色 = [011（蓝绿色）]
黄色 & 蓝绿色 = [010（绿色）]
红色 ^ 红紫色 = [001（蓝色）]
```

## 练习题 2.10

> 对于任一位向量 `a` ，有 `a ^ a = 0` 。应用这一属性，考虑下面的程序：

```C++
void inplace_swap(int* x, int* y)
{
    *y = *x ^ *y; /* STEP 1 */
    *x = *x ^ *y; /* STEP 2 */
    *y = *x ^ *y; /* STEP 3 */
}
```

...

> 以指针 `x` 和 `y` 指向的位置存储的值分别是 `a` 和 `b` 作为开始，填写下表，给出在程序的每一步之后，存储在这两个位置中的值。利用 `^` 的属性证明达到了所希望的效果。回想一下，每个元素就是它自身的加法逆元（ `a ^ a = 0` ）

解答：

```
步骤    *x           *y
初始     a            b
1->     a            a ^ b
2->     0 ^ b == b   a ^ b
3->     b            a ^ 0 = a
```

## 练习题 2.11

> 在练习题 2.10 中的 `inplace_swap` 函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：

```C++
void reverse_array(int a[], int cnt)
{
    int first, last;
    for (first = 0, last = cnt - 1; first <= last; ++first, ++last) {
        inplace_swap(&a[first], &a[last]);
    }
}
```

> ... 实际上你会发现这段代码对所有偶数长度的数组都能正确的工作，但是当数组的长度为奇数时，它就会把中间的元素设置为 `0` 。

> A. 对于一个长度为奇数的数组，长度 `cnt = 2k + 1` ，函数 `reverse_array` 最后一次循环中，变量 `first` 和 `last` 的值分别是什么？

解答：

```
first == last == (2k + 1) / 2
```

> B. 为什么这时调用函数 `inplace_swap` 会将数组元素设置为 `0` ？

解答：

```
因为两个指针指向了同一个对象，也就是同一个值。

void inplace_swap(int* x, int* y)
{   x 和 y 指向了同一个地址
    *y = *x ^ *y; -> *y == 0 => *x == 0
    ...
}
```

> C. 对 `reverse_array` 的代码做哪些简单改动就能消除这个问题？

解答：

```C++
void reverse_array(int a[], int cnt)
{
    int first, last;
    for (first = 0, last = cnt - 1; first < last; ++first, ++last) {
        inplace_swap(&a[first], &a[last]);
    }
}
```

## 练习题 2.12

> 对于下面的值，写出变量 `x` 的 C 语言表达式。你的代码应该对任何字长 `w >= 8` 的值都能工作。我们给出了当 `x = 0x87654321` 以及 `w = 32` 时表达式求值的结果，仅供参考。

> A. `x` 的最低有效字节，其他位均置为 `0` 。 `[0x00000021]`

解答：

```
0x87654321 & 0x000000FF
```

> B. 除了 `x` 的最低有效字节外，其他的位都取补，最低有效字节保持不变。 `[0x789ABC21]`

解答：

```
0x87654321 ^ 0xFFFFFF00
```

> C. `x` 的最低有效字节全部置 `1` ，其他字节都保持不变。 `[0x876543FF]`

解答：

```
0x87654321 | 0x000000FF
```

## 练习题 2.13

* `bis`（位设置）：输入一个数据字 `x` 和一个掩码字 `m` 。在 `m` 为 `1` 的每个位置上，将 返回值 `z` 对应的位设置为 `1` 。
* `bic`（位清除）：输入一个数据字 `x` 和一个掩码字 `m` 。在 `m` 为 `1` 的每个位置上，将 返回值 `z` 对应的位设置为 `0` 。

为了看清楚这些运算与 C 语言位级运算的关系，假设我们有两个函数 `bis` 和 `bic` 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 `|` 和 `^` 运算。填写下列代码中缺失的代码。提示：写出 `bis` 和 `bic` 运算的 C 语言表达式。

解答：

```C++
/* Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
    int result = [bis(x, y)];
    return result;
}

/* Compute x^y using only calls to functions bis and bic */
/* STAR */ 
int bool_xor(int x, int y) {
    int result = `bis(bic(x, y), bic(y, x))`;
            //    ~~~~~~~~~~~~~~~~~~~~~~~~~ FROM TEXT BOOK ANSWER...
    return result;
}
/* This problem is too difficult to figure out... */ 
```

## 练习题 2.14

> 假设 `x` 和 `y` 的字节值分别为 `0x66` 和 `0x39` 。填写下表，指明各个 C 表达式的字节值。

解答：

```
分析：
 x = 0b 0110 0110
~x = 0b 1001 1001
 y = 0b 0011 1001
~y = 0b 1100 0110
```

```
表达式     值
x & y     0b 0010 0000 -> 0x20
x | y     0b 0111 1111 -> 0x7F
~x | ~y   0b 1101 1111 -> 0xDF
x & !y    0b 0000 0000 -> 0x00

x && y    0b 0000 0001 -> 0x01
x || y    0b 0000 0001 -> 0x01
!x || !y  0b 0000 0000 -> 0x00
x && ~y   0b 0000 0001 -> 0x01
```

## 练习题 2.15

只使用位级和逻辑运算，编写一个 C 表达式，它等价于 `x == y` 。换句话说，当 `x` 和 `y` 相等时它将返回 `1` ，否则就返回 `0` 。

解答：

```
!(x ^ y)

解释：
已知 a ^ a == 0，那么
若 x ^ y == 0 则 x == y
若 x ^ y != 0 则 x != y
C 语言中非零值将会自动的转换成 true
```

## 练习题 2.16

> 填写下表，展示不同位移运算对单字节数的影响。思考位移运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行位移运算，然后再转换回十六进制。每个答案都应该是 8 个二进制数字或者 2 个十六进制数字。

解答：

```
x
十六进制    二进制
0xC3       11000011
0x75       01110101
0x87       10000111
0x66       01100110
```

```
x << 3
二进制        十六进制
00011000     0x18
10101000     0xA8
00111000     0x38
00110000     0x30
```

```
x >> 2（逻辑的）
二进制        十六进制
00110000     0x30
00011101     0x1D
00100001     0x21
00011001     0x19
```

```
x >> 2（算术的）
二进制        十六进制
11110000     0xF0
00011101     0x1D
11100001     0xE1
00011001     0x19
```

## 练习题 2.17

> 假设 `w = 4` ，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出等式（2.1）和等式（2.3）所示的求和公式中的 2 的非零次幂，填写下表：

解答：

```

(x)十六进制 (x)二进制    B2U(x)                      B2T(x)
0xE        [1110]      [2^3 + 2^2 + 2^1 = 14]     [-2^3 + 2^2 + 2^1 = -2]
0x0        0000        0                           0
0x5        0101        2^2 + 2^0 = 5               2^2 + 2^0 = 5
0x8        1000        2^3 = 8                     -2^3 = -8
0xD        1101        2^3 + 2^2 + 2^0 = 13        -2^3 + 2^2 + 2^0 = -3
0xF        1111        2^3 + 2^2 + 2^1 + 2^0 = 15  -2^3 + 2^2 + 2^1 + 2^0 = -1
```

## 练习题 2.18

> 在下面的列表中，对于标号为 A ~ I（标记在）的那行，将指令名（ `sub` 、`mov` 和 `add` ）右边显示的（32 位补码形式表示的）十六进制值转换为等价的十进制值。

解答：

```
sub $0x2e0 %rsp A. 226
mov -0x58 ...   B. -133
add 0x28  ...   C. 130
mov -0x30 ...   D. -48
mov 0x78  ...   E. 120
mov 0x88  ...   F. 136
mov 0x1f8 ...   G. 520
mov 0xc0  ...   H. 192
mov -0x48 ...   I. -72
```

## 练习题 2.19

> 利用你解答练习题 2.17 时填写的表格，填写下列描述函数 `T2U` 的表格。

解答：

```
x    T2U（补码形式当作源码来解读）
-8   1111 1000 -> 8
-3   1111 1101 -> 13
-2   1111 1110 -> 14
-1   1111 1111 -> 15
0    0000 0000 -> 0
5    0000 0110 -> 5
```

## 练习题 2.20

> 请说明等式（2.5）是如何应用到解答练习题 2.19 时生成的表格中的各项的。

解答：

当 `x >= 0` 时，位模式的解释出来的值不变；当 `x < 0` 时，位模式解释出来的值就会发生环绕，就是 2 的 当前位模式最大长度 的次方加上当前 `x` 的值。

## 练习题 2.21

> 假设在采用补码运算的 32 位机器上对这些表达式求值，按照图 2-19 格式填写下表，描述强制类型转换和运算关系的结果。

解答：

```
类型        求值
无符号      1
无符号      0
无符号      0
有符号      1
有符号      0
```

## 练习题 2.22

> 通过应用等式（2.3），表明下面每个位向量都是 -5 的补码表示。

解答：

```
A.[1011] -1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -5
B.[11011] -1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -16 + 8 + 2 + 1 = -5
C.[111011] 1 + 2 + 0 + 8 + 16 - 32 = -5
```

## 练习题 2.23

> 考虑下面的 C 函数：

```C
int fun1(unsigned word) {
    return (int)((word << 24) >> 24);
    // 先做位移运算，然后转换为 int
}

int fun2(unsigned word) {
    return ((int)word << 24) >> 24;
    // 左移之后转换成 int 后再右移
}
```

> 假设在一个采用补码运算的机器上以 32 位程序来执行这些函数。还假设有符号数值的右移是算术右移，而无符号数值的右移是逻辑右移。
>
> A. 填写下表，说明这些函数对几个示例参数的结果。你会发现用十六进制表示来做会更方便，只要记住十六进制数字 8 到 F 的最高有效位等于 1 。

解答：

```
w               fun1(w)                      fun2(w)
0x00000076      0x76000000->0x00000076      0x76000000->0xFFFFFF76
                                             ~~~~~~~~~~~~~~~~~~~~~~ -> 7 = 0111 -> 最高有效位 0
                                                                        应当是 0x00000076
0x87654321      0x21000000->0x00000021      0x21000000->0x00000021
0x000000C9      0xC9000000->0x000000C9      0xC9000000->0xFFFFFFC9
0xEDCBA987      0x87000000->0x00000087      0x87000000->0xFFFFFF87
```

> B.用语言来描述这些函数执行的有用的计算

解答：

```
fun1 先将无符号数左移 24 位，然后又将无符号数逻辑右移 24 位，然后当成 int 类型输出
fun2 先将无符号数转换为有符号数，将该有符号数左移 24 位，然后将该有符号数算术右移 24 位，最后输出（int）
```

## 练习题 2.24

> 假设将一个 4 位数值（用十六进制数字 0 ~ F 表示）截断到一个 3 位数值（用十六进制数字 0 ~ 7 表示）。填写下表，根据那些位模式的无符号和补码解释，说明这种截断对某些情况的结果。

解答：

```
     十六进制              无符号               补码
原始值     截断值     原始值       截断值     原始值     截断值
0         0         0|0000      0|000     0|0000    0|000
2         2         9|1001      1|000     2|0010    2|010
9|1001    1|001    11|1011      3|000     -7|1001   1|001
B|1011    3|011    15|1111      7|111     -5|1011   3|011
F|1111    7|111     2|0010      2|010     -1|1111   -1|111
```

## 练习题 2.25

> 考虑下列代码，这段代码试图计算数组 `a` 中所有元素的和，其中元素的数量由参数 `length` 给出。
>
> ```C
> /* WARNING: This is buggy code */
> float sum_elements(float a[], unsigned length) {
>     int i;
>     float result = 0;
>     
>     for (i = 0; i <= length - 1; i++)
>         result += a[i];
>     return result;
> }
> ```
>
> 当参数 `length` 等于 `0` 时，运行这段代码应该返回 `0.0` 。但实际上，运行时会遇到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码。

解答：

```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;
    // 当 length == 0 时
    // i = 0 时，i <= 0 - 1 = -1 若 length 为有符号数，但是这里 length 为无符号数
    // 所以 length 会发生环绕 成为 UT_max
    // 并且在不等式判断中，i 会被转换成无符号数，然后就会在一个远超数组长度的范围内开始循环
    // 最终访问越界
    for (i = 0; i <= length - 1; i++)
        result += a[i];
    return result;
}

// 修改之后：
float sum_elements(float a[], unsigned length) {
    float result = 0;
    for (unsigned i = 0; i < length; ++i) { result += a[i]; }
    return result;
}
```

## 练习题 2.26

> 现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数 `strlen` ，它的声明如下：
>
> ```C
> /* Prototype for library funciton strlen */
> size_t strlen(const char* s);
> ```
>
> 最开始你写的函数是这样的：
>
> ```C
> /* Determine whether string s is longer than string t */
> /* WRANING: This function is buggy */
> int strlonger(char* s, char* t) {
>     return strlen(s) - strlen(t) > 0;
> }
> ```
>
> 当你在一些示例数据上测试这个函数时，一切似乎都是正确的。进一步研究发现在头文件 `stdio.h` 中数据类型 `size_t` 是定义成 `unsigned int` 的。
>
> A. 在什么情况下，这个函数会产生不正确的结果？

解答：

当字符串 `t` 的长度大于 `s` 的长度时，就会产生不正确的结果。

> B. 解释为什么会出现这样不正确的结果。

解答：

因为 `strlen` 函数返回的是无符号数，当两个无符号数运算时产生的结果也是无符号数，当运算结果为负数时就会产生不正确的计算结果。

> C. 说明如何修改这段代码好让它能可靠的工作。

解答：

```C
int strlonger(char* s, char* t) {
    if (strlen(s) < strlen(t)) return -1;
    else if (strlen(t) < strlen(s)) return 1;
    else return 0;
}
```

## 练习题 2.27

> 写出一个具有如下原型的函数：
>
> ```C
> /* Determin whether arguments can be added without overflow */
> int uadd_ok(unsigned x, unsigned y);
> ```
>
> 如果参数 `x` 和 `y` 相加不会产生溢出，这个函数就返回 `1` 。

解答：

```C
int uadd_ok(unsigned x, unsigned y)
	{ return (x + y < x || x + y < y) ? 0 : 1; }
```

## 练习题 2.28

> 我们能用一个十六进制数字来表示长度 `w = 4` 的位模式。对于这些数字的无符号解释，使用等式（2.12）填写下表，给出所示数字的无符号加法逆元的位表示（用十六进制形式）。

解答：

```
x                   -u_4_x
十六进制    十进制    十进制     十六进制
0          0        0         0
5          5        11        B
8          8        8         8
D          13       3         3
F          15       1         1
```

## 练习题 2.29

> 按照图 2-25 的形式填写下表。分别列出 5 位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式（2.13）推导中的哪种情况。

解答： 

```
-12[10100] -15[10001] -27[100101] 5[00101] 负溢出
-8[11000] -8[11000] -16[110000] -16[10000] 正常
-9[10111] 8[01000] -1[111111] -1[11111] 正常
2[00010] 5[00101] 7[000111] 7[00111] 正常
12[01100] 4[00100] 16[010000] -16[10000] 正溢出
```

## 练习题 2.30

> 写出一个具有如下原型的函数：
>
> ```C
> /* Determin whether arguments can be added without overflow */
> int tadd_ok(int x, int y);
> ```
>
> 如果参数 `x` 和 `y` 相加不会产生溢出，这个函数就返回 `1` 。

解答：

```C
int tadd_ok(int x, int y) {
    int ans = x + y;
    if (x > 0 && y > 0 || ans < 0) return 0;
    if (x < 0 && y < 0 || ans > 0) return 0;
    return 1;
}
```

## 练习题 2.31

> 你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数 `tadd_ok` 的实现，如下所示：
>
> ```C
> /* Determine whether arguments can be added without overflow */
> /* WARNING: This code is buggy */
> int tadd_ok(int x, int y) {
>     int sum = x + y;
>     return (sum - x == y) && (sum - y == x);
> }
> ```
>
> 你看了代码以后笑了。解释一下为什么。

解答：

补码加法会形成一个阿贝尔群，无论是否产生溢出， `(x + y) - y` 的答案总是 `x` 。

## 练习题 2.32

> 你现在有个任务，编写函数 `tsub_ok` 的代码，函数的参数是 `x` 和 `y` ，如果计算 `x - y` 不产生溢出，函数就返回 `1` 。假设你写的练习题 2.30 的代码如下所示：
>
> ```C
> /* Determine whether arguments can be subtracted without overflow */
> /* WARNING: This code is buggy */
> int tsub_ok(int x, int y) {
>        return tadd_ok(x, -y);
> }
> ```
>
> `x` 和 `y` 取什么值时，这个函数会产生错误的结果？

解答：

当 `x == TMAX && y == TMIN` 时，函数的输出会产生错误。

## 练习题 2.33

> 我们可以用一个十六进制数字来表示长度 `w = 4` 的位模式。根据这些数字的补码解释，填写下表，确定所示数字的加法逆元。

解答：

```
x                  -x
十六进制    十进制   十进制    十六进制
0          0       0        0
5          5       -5       B
8          -8      -8       8
D          -3      3        3
F          -1      1        1
```

## 练习题 2.34

> 按照图 2-27 的风格填写下表，说明不同的 3 位数字乘法的结果。

解答：

```
[100]4 [101]5 [010100]20 [100]4
[100]-4 [101]-3 [001100]12 [100]-4

[010]2 [111]7 [001110]14 [110]6
[010]2 [111]-1 [111110]-2 [110]-2

[110]6 [110]6 [100100]36 [100]4
[110]-2 [110]-2 [000100]4 [100]-4
```

## 练习题 2.35



## 练习题 2.36

> 对于数据类型 `int` 位 32 位的情况，设计一个版本的 `tmult_ok` 函数（ 练习题 2.35 ），使用 64 位精度的数据类型 `int64_t` ，而不使用除法。



## 练习题 2.37

> 现在你有一个任务，当数据类型 `int` 和 `size_t` 都是 32 位的，修补上述旁注给出的 XDR 代码中的漏洞。你决定将待分配字节数设置为数据类型 `int64_t` ，来消除乘法溢出的可能性。你把原来对 `malloc` 函数的调用替换如下：
>
> ```C
> uint64_t asize = 
>     ele_cnt * (uint64_t)ele_size;
> void* result = malloc(asize);
> ```
>
> 提醒一下， `malloc` 的参数类型是 `size_t` 。
>
> A. 这段代码对原始的代码有了哪些改进？
>
> B. 你该如何修改代码来消除这个漏洞？

解答：

```C
/* TextBook Version Code */

void* copy_elements(void* ele_src[], int ele_cnt, size_t ele_size)
{
    /* May overflow: int->unsigned * size_t */
    /* void* result = malloc(ele_cnt * ele_size); */
    /* So we Change it to...  */
    uint64_t asize = ele_cnt * (uint64_t)ele_size;
    void* result = malloc(asize);
    if (result == NULL) {
        return NULL; /* malloc failed */
    }
    void* next = result;
    int i;
    for (i = 0; i < ele_cnt; ++i) {
        memcpy(next, ele_src[i], ele_size);
        next += ele_size;
    }
    return result;
}
```

A. 首先对于原始代码的改动避免了计算直接溢出的问题，但是还是没有彻底避免溢出的发生。因为在产生的计算结果无法用 32 位表示但是可以用 64 位表示的情况下，还是会发生溢出，只不过由 64 位向 32 位转换时被切断了。但是即使这样得到的结果肯定还是不准确的。

B. 修改的方式如下：

```C
/* Fixed Version */

void* copy_elements(void* ele_src[], int ele_cnt, size_t ele_size)
{
    size_t total_bytes = ele_cnt * ele_size;
    void* result = NULL;
    if (total_bytes / ele_cnt == ele_size) {
        /* If does not overflow, malloc */
        result = malloc(total_bytes);
    }
    if (result == NULL) {
        return NULL; /* malloc failed */
    }
    void* next = result;
    int i;
    for (i = 0; i < ele_cnt; ++i) {
        memcpy(next, ele_src[i], ele_size);
        next += ele_size;
    }
    return result;
}
```

## 练习题 2.38

> 就像我们将在第 3 章中看到的那样， `LEA` 指令能够执行形如 `(a << k) + b` 的计算，这里 `k = 0, 1, 2, 3` 。而 `b` 等于 `0` 或者某个程序值。编译器常常用这条指令来执行常数因子乘法。 考虑 `b` 等于 0 或者等于 `a` ， `k` 为任意可能值的情况，用一条 `LEA` 指令可以计算 `a` 的哪些倍数？

解答：

```
(1) b == 0 ===> (a << k)
当前情况下可以计算 a 的 2^k 倍；

(2) b == a ===> (a << k) + a
当前情况下可以计算 a * 2^k + a == a * (2^k + 1)
也就是可以计算 a 的 2^k + 1 倍；
```

## 练习题 2.39

> 对于位置 $n$ 为最高有效位的情况，我们要怎么样修改形式 B 的表达式？

解答：

形式 B 的本质是 $x*2^{n+1}-x*2^m$ 。也就是计算 $x*(2^{n}-2^{m-1})*2$ 

```
((x << n) - (x << (m-1))) << 1
```

## 练习题 2.40

> 对于下面每个 K 的值，找出指定数量的运算表达式 `x * K` 的方法，这里我们认为加法和减法的开销相当。除了我们已经考虑过的简单的形式 A 和 B 原则，你可能会需要使用一些技巧。

解答：

```
K    位移    加法/减法    表达式
6    2      1           x*6 = x << 3 - x << 1
31   1      1           x*31 = x << 5 - x
-6   2      1           x*-6(2-8) = x << 1 - x << 3
55   2      2           x << 6 - (x << 3 + x)
```

## 练习题 2.41

> 对于一组从位位置 $n$ 开始到位位置 $m$ 的连续的 $1$ （ $n \ge m$ ），我们看到可以产生两种形式的代码， A 和 B 。编译器该如何决定使用哪一种呢？

解答：

当最高位只有 $n$ 位时选择形式 A ，否则选择 B 。

## 练习题 2.42

> 写一个函数 `div16` ，对于整数参数 `x` 返回 `x/16` 的值，你的函数不能使用除法、模运算、乘法、任何条件语句任何比较运算符或者任何循环。你可以假设数据类型是 32 位长，使用补码表示，而且右移是算术右移。

解答：

```C
int div16(int x)
{
    /* 16 = 2^4 ==> x >> 4 */
    return x >> 4;
}
```

## 练习题 2.43

> 下面的代码中，我们省略了常数 `M` 和 `N` 的定义：
>
> ```C
> #define M /* Mystery number 1 */
> #define N /* Mystery number 2 */
> 
> int arith(int x, int y)
> {
>     int result = 0;
>     result = x * M + y / N;
>     return result;
> }
> ```
>
> 我们以某个 `M` 和 `N` 的值编译这段代码。编译器用我们讨论过的方法优化乘法和除法。下面将是产生出的机器代码翻译会 C 语言的结果：
>
> ```C
> /* Translation of assembly code for arith */
> int optarith(int x, int y)
> {
>     int t = x;
>     x <<= 5;
>     x -= t;
>     if (y < 0) y += 7;
>     y >>= 3; /* Arithmetic shift */
>     return x + y;
> }
> ```
>
> `M` 和 `N` 的值为多少？

解答：

首先我们来分析翻译出来的代码：

```C
/* Translation of assembly code for arith */
int optarith(int x, int y)
{
    int t = x; /* t is orign x */
    x <<= 5;   /* x = x * 2^5 */
    x -= t;    /* x * 2^5 - x * 2^0 */
    /* So x is [x * (2^5 - 1)] */
    /* So M gonna be 32 - 1 == 31*/
    
    if (y < 0) y += 7; /* This option is for rounding */
    y >>= 3;           /* Arithmetic shift */
    /* y >> 3 == [y / 2^3] ==> y / 8 */
    /* So N gonna be 8 */
    return x + y;
}
```

```C
#define M 31
#define N 8
```

## 练习题 2.44

> 假设我们在对有符号值使用补码运算的 32 位机器上运行代码。对于有符号值使用的是算术右移，而对于无符号值使用的是逻辑右移。变量的声明和初始化如下：
>
> ```C
> int x = foo(); /* Arbitary value */
> int y = bar(); /* Arbitary value */
> 
> unsigned ux = x;
> unsigned uy = y;
> ```
>
> 对于下面每个 C 表达式： 1)证明对于所有的 `x` 和 `y` 值，它都为真；或者 2)给出使得它为假的 `x` 和 `y` 值。

解答：

```
A. (x > 0) || (x - 1 < 0) ==> FALSE
Consider the Tmin and Tmax...
(Tmin > 0)FALSE || (Tmin - 1 == Tmax < 0)FALSE

B. (x & 0111) != 7 || (x << 29 < 0) ==> FALSE
Consider the Tmin...
(1000..0000 & 000...0111) != 7 --> FALSE
(1000..0000 << 29) < 0 --> FALSE

C. (x * x) >= 0 ==> FALSE
May Overflow...

D. x < 0 || -x <= 0 ==> TRUE
Tmin < 0 || -Tmin < 0

E. x > 0 || -x >= 0 ==> FALSE
Tmin > 0(FALSE) || -Tmin >= 0(FALSE)

F. x + y == uy + ux ==> TRUE
Tmin + Tmax == 0111 + 1000 ==> 1111 ==> -1 or 15

G. x * ~y + uy * ux == -x
TODO
```

## 练习题 2.45

> 填写下表中的缺失的信息：

解答：

```
小数值    二进制表示    十进制表示
1/8      0.001        0.125
3/4      [0.11]       [0.75]
25/16    [1.1001]     [1.5625]
```

这个练习的核心在于，十进制情况下，底数是 10 ，而二进制情况下，指数的底数是 2 。

```
25 / 26 ==> 25 * 0.0001
25 的二进制表示 = 11001
原式 = 11001 * 0.0001 ==> 1.1001 （二进制）
转换为十进制为：2^0 + 2^-1 + 2^-4 = 1 + 1/2 + 1/(2^4)
1 + 0.5 + 0.0625 ==> 1.5625
```

核心思路在于先将分子分母转换为二进制，然后得到二进制的小数，最后根据基底进行换算。

## 练习题 2.46

> 海湾战争相关……
>
> 现在考虑 x = 0.00011001100110011001100 这个二进制序列：
>
> A. 0.1 - x 的二进制表示是什么？
>
> B. 0.1 - x 的近似十进制值是多少？
>
> C. 当系统初始启动时，时钟从 0 开始，并且一直保持计数。在这个例子中，系统已经运行了大约 100 个小时。程序计算出的事件和实际的事件之差为多少？
>
> D. 系统根据一枚来袭的导弹的速率和它最后被雷达侦测到时间，来预测它将在哪里出现。假定飞毛腿的速率大约是 2000 米每秒，对它的预测偏差了多少？

解答：

```
A. 0.000000000000000000000001[1001]...(2)
```

```
B. 0.00000009522
```

```
C. 计数器是每 0.1 秒 增加 1
也就是这个系统中的 0.1 秒比真实世界中的 0.1 秒快 0.00000009522 秒
100 个小时 = 100 * 3600 秒 = 360000 秒 也就是 3600000 个 0.1 秒
即系统中的时间将比真实世界的时间快 0.00000009522 * 3600000 秒
也就是 0.342792 秒
```

```
D. 那么这个预测将偏差 0.342792 * 2000 = 685.584 米
```



练习题 2.47 - PASS



## 练习题 2.48

> 正如在练习 2.6 中提到的，整数 3 510 593 的十六进制表示为 0x00359141 ，而单精度浮点数 3510593.0 的十六进制表示为 0x4A564504 。推导出这个浮点表示，并且解释整数和浮点数表示的位之间的关系。

解答：

```
# 先将所有的十六进制转化为二进制序列：
3510593   = 1101011001000101000001
3510593.0 = 1001010010101100100010100000100
# 然后将序列相同的部分对齐：
3510593   =            1[101011001000101000001]
3510593.0 = [1][0010100][101011001000101000001]00
# 单精度浮点
# 符号位：1
# 阶码：0010100 - 也就是规格化的值，那么小数部分开头有个隐藏的 1
# 小数部分：1.10101100100010100000100 注意这个开头的 1 是隐藏的
# 整理得到：
# 1.101011001000101000001
# 1[101011001000101000001]
```

## 练习题 2.49 #

> A. 对于一种具有 n 位小数的浮点格式，给出不能准确描述的最小正整数的公式（因为要想准确表示它需要 n + 1 位小数）。假设阶码字段长度 k 够大，可以表示的阶码范围不会限制这个问题。
>
> B. 对于单精度格式 （n = 23），这个整数的数字值是多少？

解答：

```
A.
```

## 练习题 2.50

> 根据舍入到偶数规则，说明如何将下列二进制小数值舍入到最接近的二分之一（二进制小数点右边 1 位）。对每种情况，给出舍入前后的数字值。

解答：

```
# 01(1) 10(2) 11(3)

A. 10.010(2)
   10.0[10] ==> 10.0
B. 10.011(2)
   10.0[11] ==> 10.1
C. 10.110(2)
   10.1[10] ==> 11.0
D. 11.001(2)
   11.0[01] ==> 11.0 
```

## 练习题 2.51

> 还是海湾战争的问题，如果使用 IEEE 舍入到偶数的方式来确定 0.1 的二进制小数点右边 23 位的近似表示 x' ：
>
> A. x' 的二进制表示是什么？
>
> B. x' - 0.1 的十进制表示的近似值是什么？
>
> C. 运行 100 个小时之后，计算时钟值会有多少偏差？
>
> D. 该程序对飞毛腿导弹位置的预测会有多少偏差？

解答：

```
# A.
     0.00011001100110011001100,110011001
采用舍入到偶数的方式：
x' = 0.00011001100110011001101

# B.
0.00011001100110011001101 - 0.1
===> 0.10000002384185791016 - 0.1
===> 0.00000002384185791016

# C.
0.00000002384185791016 * 3600000
===> 0.085830688476576

# D.
0.085830688476576 * 2000 = 171.661376953152 米
```

## 练习题 2.52

> 考虑下列基于 IEEE 浮点格式的 7 位浮点表示。两个格式都没有符号位——它们只能表示非负的数字：
>
> ……

解答：

| 位         | 值    | 位         | 值    |
| ---------- | ----- | ---------- | ----- |
| `011 0000` | `1`   | `0111 000` | `1`   |
| `101 1110` | `7.5` | `0101 111` | `7.5` |
| `010 1001` |       |            |       |
| `110 1111` |       |            |       |
| `000 0001` |       |            |       |

```
101 => 5 ==> exp = 5 bias = 3
===> E = 5 - 3 == 2
2^2 * 1.1110 == 4 * (1 + 1/2 + 1/4 + 1/8)
```

方法就是使用 IEEE 的计算法则来确定表示的值，并且在位数不够的情况下进行向偶数舍入。

## 练习题 2.53 #

> 完成下列宏定义，生成双精度值 正无穷，负无穷 和 0

解答：

```
#define POS_INFINITY
#define NEG_INFINITY
#define NEG_ZERO
```

## 练习题 2.54



解答：当前练习题公开课笔记中有详解。

