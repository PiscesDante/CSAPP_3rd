# 第2章 信息的表示和处理

## 练习题 2.1

完成下面的数字转换：

* 将 `0x39A7F8` 转换为二进制。
* 将二进制 `1100100101111011` 转换为十六进制。
* 将 `0xD5E4C` 转换为二进制。
* 将二进制 `1001101110011110110101` 转换为十六进制。

解答：

使用 辅助程序 文件夹中的 `number_form_converter.hpp` 即可完成相应的转换。

```C++
#include "./number_form_converter.hpp"

int main(int argc, char** argv)
{
    std::cout << hexadecimal_to_binary("0x39A7F8") << std::endl;
    std::cout << binary_to_hexadecimal("1100100101111011") << std::endl;
    std::cout << hexadecimal_to_binary("0xD5E4C") << std::endl;
    std::cout << binary_to_hexadecimal("1001101110011110110101") << std::endl;
    // 001110011010011111111000
    // 0xC97B
    // 11010101111001001100
    // 0x26E7B5
    return 0;
}
```

## 练习题 2.2

填写下表中的空白项，给出 2 的不同次幂的十进制和十六进制的表示：（图表见书）

解答：

```
n     2^n（十进制）   2^n（十六进制）
9     512            0x200
19    [524288]       [0x80000]
[14]  16384          [0x4000]
[16]  [65536]        0x10000
17    [131072]       [0x20000]
[5]   32             [0x20]
[7]   [128]          0x80
```

## 练习题 2.3

> 一个字节可以用两个十六进制数字来表示。填写下表中缺失的项，给出不同字节模式的十进制、二进制和十六进制的值：

解答：

```
十进制       二进制          十六进制
0           0000 0000      0x00
167         [1010 0111]    [0xA7]
62          [0011 1110]    [0x3E]
188         [1011 1100]    [0xBC]
[55]        0011 0111      [0x37]
[136]       1000 1000      [0x88]
[82]        [0101 0010]    0x52
[172]       [1010 1100]    0xAC
[231]       [1110 0111]    0xE7
```

## 练习题 2.4

> 不将数字转换为十进制或者二进制，试着解答下面的算术题，答案要用十六进制表示。提示：只要将执行十进制加法和减法所使用的方法改成以 `16` 为基数。

解答：

```
A. 0x503C + 0x8 = [0x5044]
B. 0x503C - 0x40 = [0x4FFC]
C. 0x503C + 64 = [0x50A0]
D. 0x50EA - 0x503C = [0x00AE]
```

## 练习题 2.5

> 思考下面对 `show_bytes` 的三次调用：

```C++
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1); /* A. */
show_bytes(valp, 2); /* B. */
show_bytes(valp, 3); /* C. */
```

> 指出在小端法机器和大端法机器上，每次调用的输出值。

解答：

```
分析：
十六进制的 1 位代表二进制的 4 位：
0x87654321 -> 1000 0111 0110 0101 0100 0011 0010 0001
A. 打印 1 个字节 -> 8 位
B. 打印 2 个字节 -> 16 位
C. 打印 3 个字节 -> 24 位

结果：
A. 小端法：[21]       大端法：[87]
B. 小端法：[21 43]    大端法：[87 65]
C. 小端法：[21 43 65] 大端法：[87 65 43]
```

## 练习题 2.6

> 使用 `show_int` 和 `show_float` ，我们确定整数 `3510593` 的十六进制表示为 `0x00359141` ，而浮点数 `3510593.0` 的十六进制表示为 `0x4A564504` 。


> A. 写出这两个十六进制值的二进制表示。

解答：

```
0x00359141 -> 0b 0000 0000 0011 0101 1001 0001 0100 0001
0x4A564504 -> 0b 0100 1010 0101 0110 0100 0101 0000 0100
```

> B. 移动这两个二进制串的相对位置，使得它们相匹配的位数最多。有多少位相匹配呢？

解答：

```
00000000001 101011001000101000001
  010010100 101011001000101000001 00 

一共有 21 位匹配
```

> C. 串中的什么部分不相匹配？

解答：

```
串中前面的一部分和后面的一部分不匹配。
```

## 练习题 2.7

> 下面对 `show_bytes` 的调用将输出什么结果？

```C++
const char* s = "abcdef";
show_bytes((byte_pointer) s, strlen(s));
// 注意字母 a ~ z 的 ASCII 码为 0x61 ~ 0x7A
```

解答：

```
61 62 63 64 65 66
```

## 练习题 2.8

> 填写下表，给出位向量的布尔运算求值结果。

解答：

```
a = 01101001
b = 01010101
~a = [10010110]
~b = [10101010]
a & b = [01000001]
a | b = [01111101]
a ^ b = [00111100]
```

## 练习题 2.9

通过混合三种不同颜色的光（红色、绿色和蓝色），计算机可以在视频屏幕或者液晶显示器上产生彩色的画面。设想一种简单地方法，使用三种不同颜色的光，每种光都能打开或者关闭，投射到玻璃屏幕上，如图所示。

那么基于光源 `R`（红）、`G`（绿）、`B`（蓝）的关闭（ `0` ）或者打开（ `1` ），我们就能创建 `8` 种不同的颜色。

这些颜色中的每一种都能用一个长度为 `3` 的位向量来表示，我们可以对它们进行布尔运算。

> A. 一种颜色的 补 是通过关掉打开的光源，且打开关掉的光源而形成的。那么上面列出的 `8` 中颜色的每一种的 补 是什么？

解答：

```
~黑色 = 111（白色）
~蓝色 = 110（黄色）
~绿色 = 101（红紫色）
~蓝绿色 = 100（红色）
~红色 = 011（蓝绿色）
~红紫色 = 010（绿色）
~黄色 = 001（蓝色）
~白色 = 000（黑色）
```

> B. 描述下列颜色应用布尔运算的结果：

解答：

```
蓝色 | 绿色 = [011（蓝绿色）]
黄色 & 蓝绿色 = [010（绿色）]
红色 ^ 红紫色 = [001（蓝色）]
```

## 练习题 2.10

> 对于任一位向量 `a` ，有 `a ^ a = 0` 。应用这一属性，考虑下面的程序：

```C++
void inplace_swap(int* x, int* y)
{
    *y = *x ^ *y; /* STEP 1 */
    *x = *x ^ *y; /* STEP 2 */
    *y = *x ^ *y; /* STEP 3 */
}
```

...

> 以指针 `x` 和 `y` 指向的位置存储的值分别是 `a` 和 `b` 作为开始，填写下表，给出在程序的每一步之后，存储在这两个位置中的值。利用 `^` 的属性证明达到了所希望的效果。回想一下，每个元素就是它自身的加法逆元（ `a ^ a = 0` ）

解答：

```
步骤    *x           *y
初始     a            b
1->     a            a ^ b
2->     0 ^ b == b   a ^ b
3->     b            a ^ 0 = a
```

## 练习 2.11

> 在练习题 2.10 中的 `inplace_swap` 函数的基础上，你决定写一段代码，实现将一个数组中的元素头尾两端依次对调。你写出下面这个函数：

```C++
void reverse_array(int a[], int cnt)
{
    int first, last;
    for (first = 0, last = cnt - 1; first <= last; ++first, ++last) {
        inplace_swap(&a[first], &a[last]);
    }
}
```

> ... 实际上你会发现这段代码对所有偶数长度的数组都能正确的工作，但是当数组的长度为奇数时，它就会把中间的元素设置为 `0` 。

> A. 对于一个长度为奇数的数组，长度 `cnt = 2k + 1` ，函数 `reverse_array` 最后一次循环中，变量 `first` 和 `last` 的值分别是什么？

解答：

```
first == last == (2k + 1) / 2
```

> B. 为什么这时调用函数 `inplace_swap` 会将数组元素设置为 `0` ？

解答：

```
因为两个指针指向了同一个对象，也就是同一个值。

void inplace_swap(int* x, int* y)
{   x 和 y 指向了同一个地址
    *y = *x ^ *y; -> *y == 0 => *x == 0
    ...
}
```

> C. 对 `reverse_array` 的代码做哪些简单改动就能消除这个问题？

解答：

```C++
void reverse_array(int a[], int cnt)
{
    int first, last;
    for (first = 0, last = cnt - 1; first < last; ++first, ++last) {
        inplace_swap(&a[first], &a[last]);
    }
}
```

## 练习题 2.12

> 对于下面的值，写出变量 `x` 的 C 语言表达式。你的代码应该对任何字长 `w >= 8` 的值都能工作。我们给出了当 `x = 0x87654321` 以及 `w = 32` 时表达式求值的结果，仅供参考。

> A. `x` 的最低有效字节，其他位均置为 `0` 。 `[0x00000021]`

解答：

```
0x87654321 & 0x000000FF
```

> B. 除了 `x` 的最低有效字节外，其他的位都取补，最低有效字节保持不变。 `[0x789ABC21]`

解答：

```
0x87654321 ^ 0xFFFFFF00
```

> C. `x` 的最低有效字节全部置 `1` ，其他字节都保持不变。 `[0x876543FF]`

解答：

```
0x87654321 | 0x000000FF
```

## 练习题 2.13

* `bis`（位设置）：输入一个数据字 `x` 和一个掩码字 `m` 。在 `m` 为 `1` 的每个位置上，将 返回值 `z` 对应的位设置为 `1` 。
* `bic`（位清除）：输入一个数据字 `x` 和一个掩码字 `m` 。在 `m` 为 `1` 的每个位置上，将 返回值 `z` 对应的位设置为 `0` 。

为了看清楚这些运算与 C 语言位级运算的关系，假设我们有两个函数 `bis` 和 `bic` 来实现位设置和位清除操作。只想用这两个函数，而不使用任何其他 C 语言运算，来实现按位 `|` 和 `^` 运算。填写下列代码中缺失的代码。提示：写出 `bis` 和 `bic` 运算的 C 语言表达式。

解答：

```C++
/* Declarations of functions implementing operations bis and bic */
int bis(int x, int m);
int bic(int x, int m);

/* Compute x|y using only calls to functions bis and bic */
int bool_or(int x, int y) {
    int result = [bis(x, y)];
    return result;
}

/* Compute x^y using only calls to functions bis and bic */
/* STAR */ 
int bool_xor(int x, int y) {
    int result = `bis(bic(x, y), bic(y, x))`;
            //    ~~~~~~~~~~~~~~~~~~~~~~~~~ FROM TEXT BOOK ANSWER...
    return result;
}
/* This problem is too difficult to figure out... */ 
```

## 练习题 2.14

> 假设 `x` 和 `y` 的字节值分别为 `0x66` 和 `0x39` 。填写下表，指明各个 C 表达式的字节值。

解答：

```
分析：
 x = 0b 0110 0110
~x = 0b 1001 1001
 y = 0b 0011 1001
~y = 0b 1100 0110
```

```
表达式     值
x & y     0b 0010 0000 -> 0x20
x | y     0b 0111 1111 -> 0x7F
~x | ~y   0b 1101 1111 -> 0xDF
x & !y    0b 0000 0000 -> 0x00

x && y    0b 0000 0001 -> 0x01
x || y    0b 0000 0001 -> 0x01
!x || !y  0b 0000 0000 -> 0x00
x && ~y   0b 0000 0001 -> 0x01
```

## 练习题 2.15

只使用位级和逻辑运算，编写一个 C 表达式，它等价于 `x == y` 。换句话说，当 `x` 和 `y` 相等时它将返回 `1` ，否则就返回 `0` 。

解答：

```
!(x ^ y)

解释：
已知 a ^ a == 0，那么
若 x ^ y == 0 则 x == y
若 x ^ y != 0 则 x != y
C 语言中非零值将会自动的转换成 true
```

## 练习题 2.16

> 填写下表，展示不同位移运算对单字节数的影响。思考位移运算的最好方式是使用二进制表示。将最初的值转换为二进制，执行位移运算，然后再转换回十六进制。每个答案都应该是 8 个二进制数字或者 2 个十六进制数字。

解答：

```
x
十六进制    二进制
0xC3       11000011
0x75       01110101
0x87       10000111
0x66       01100110
```

```
x << 3
二进制        十六进制
00011000     0x18
10101000     0xA8
00111000     0x38
00110000     0x30
```

```
x >> 2（逻辑的）
二进制        十六进制
00110000     0x30
00011101     0x1D
00100001     0x21
00011001     0x19
```

```
x >> 2（算术的）
二进制        十六进制
11110000     0xF0
00011101     0x1D
11100001     0xE1
00011001     0x19
```

## 练习题 2.17

> 假设 `w = 4` ，我们能给每个可能的十六进制数字赋予一个数值，假设用一个无符号或者补码表示。请根据这些表示，通过写出等式（2.1）和等式（2.3）所示的求和公式中的 2 的非零次幂，填写下表：

解答：

```

(x)十六进制 (x)二进制    B2U(x)                      B2T(x)
0xE        [1110]      [2^3 + 2^2 + 2^1 = 14]     [-2^3 + 2^2 + 2^1 = -2]
0x0        0000        0                           0
0x5        0101        2^2 + 2^0 = 5               2^2 + 2^0 = 5
0x8        1000        2^3 = 8                     -2^3 = -8
0xD        1101        2^3 + 2^2 + 2^0 = 13        -2^3 + 2^2 + 2^0 = -3
0xF        1111        2^3 + 2^2 + 2^1 + 2^0 = 15  -2^3 + 2^2 + 2^1 + 2^0 = -1
```

## 练习题 2.18

> 在下面的列表中，对于标号为 A ~ I（标记在）的那行，将指令名（ `sub` 、`mov` 和 `add` ）右边显示的（32 位补码形式表示的）十六进制值转换为等价的十进制值。

解答：

```
sub $0x2e0 %rsp A. 226
mov -0x58 ...   B. -133
add 0x28  ...   C. 130
mov -0x30 ...   D. -48
mov 0x78  ...   E. 120
mov 0x88  ...   F. 136
mov 0x1f8 ...   G. 520
mov 0xc0  ...   H. 192
mov -0x48 ...   I. -72
```

## 练习题 2.19

> 利用你解答练习题 2.17 时填写的表格，填写下列描述函数 `T2U` 的表格。

解答：

```
x    T2U（补码形式当作源码来解读）
-8   1111 1000 -> 8
-3   1111 1101 -> 13
-2   1111 1110 -> 14
-1   1111 1111 -> 15
0    0000 0000 -> 0
5    0000 0110 -> 5
```

## 练习题 2.20

> 请说明等式（2.5）是如何应用到解答练习题 2.19 时生成的表格中的各项的。

解答：

当 `x >= 0` 时，位模式的解释出来的值不变；当 `x < 0` 时，位模式解释出来的值就会发生环绕，就是 2 的 当前位模式最大长度 的次方加上当前 `x` 的值。

## 练习题 2.21

> 假设在采用补码运算的 32 位机器上对这些表达式求值，按照图 2-19 格式填写下表，描述强制类型转换和运算关系的结果。

解答：

```
类型        求值
无符号      1
无符号      0
无符号      0
有符号      1
有符号      0
```

## 练习题 2.22

> 通过应用等式（2.3），表明下面每个位向量都是 -5 的补码表示。

解答：

```
A.[1011] -1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -5
B.[11011] -1*2^4 + 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = -16 + 8 + 2 + 1 = -5
C.[111011] 1 + 2 + 0 + 8 + 16 - 32 = -5
```

## 练习题 2.23

> 考虑下面的 C 函数：

```C
int fun1(unsigned word) {
    return (int)((word << 24) >> 24);
    // 先做位移运算，然后转换为 int
}

int fun2(unsigned word) {
    return ((int)word << 24) >> 24;
    // 左移之后转换成 int 后再右移
}
```

> 假设在一个采用补码运算的机器上以 32 位程序来执行这些函数。还假设有符号数值的右移是算术右移，而无符号数值的右移是逻辑右移。
>
> A. 填写下表，说明这些函数对几个示例参数的结果。你会发现用十六进制表示来做会更方便，只要记住十六进制数字 8 到 F 的最高有效位等于 1 。

解答：

```
w               fun1(w)                      fun2(w)
0x00000076      0x76000000->0x00000076      0x76000000->0xFFFFFF76
                                             ~~~~~~~~~~~~~~~~~~~~~~ -> 7 = 0111 -> 最高有效位 0
                                                                        应当是 0x00000076
0x87654321      0x21000000->0x00000021      0x21000000->0x00000021
0x000000C9      0xC9000000->0x000000C9      0xC9000000->0xFFFFFFC9
0xEDCBA987      0x87000000->0x00000087      0x87000000->0xFFFFFF87
```

> B.用语言来描述这些函数执行的有用的计算

解答：

```
fun1 先将无符号数左移 24 位，然后又将无符号数逻辑右移 24 位，然后当成 int 类型输出
fun2 先将无符号数转换为有符号数，将该有符号数左移 24 位，然后将该有符号数算术右移 24 位，最后输出（int）
```

## 练习题 2.24

> 假设将一个 4 位数值（用十六进制数字 0 ~ F 表示）截断到一个 3 位数值（用十六进制数字 0 ~ 7 表示）。填写下表，根据那些位模式的无符号和补码解释，说明这种截断对某些情况的结果。

解答：

```
     十六进制              无符号               补码
原始值     截断值     原始值       截断值     原始值     截断值
0         0         0|0000      0|000     0|0000    0|000
2         2         9|1001      1|000     2|0010    2|010
9|1001    1|001    11|1011      3|000     -7|1001   1|001
B|1011    3|011    15|1111      7|111     -5|1011   3|011
F|1111    7|111     2|0010      2|010     -1|1111   -1|111
```

## 练习题 2.25

> 考虑下列代码，这段代码试图计算数组 `a` 中所有元素的和，其中元素的数量由参数 `length` 给出。
>
> ```C
> /* WARNING: This is buggy code */
> float sum_elements(float a[], unsigned length) {
>     int i;
>     float result = 0;
>     
>     for (i = 0; i <= length - 1; i++)
>         result += a[i];
>     return result;
> }
> ```
>
> 当参数 `length` 等于 `0` 时，运行这段代码应该返回 `0.0` 。但实际上，运行时会遇到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码。

解答：

```C
/* WARNING: This is buggy code */
float sum_elements(float a[], unsigned length) {
    int i;
    float result = 0;
    // 当 length == 0 时
    // i = 0 时，i <= 0 - 1 = -1 若 length 为有符号数，但是这里 length 为无符号数
    // 所以 length 会发生环绕 成为 UT_max
    // 并且在不等式判断中，i 会被转换成无符号数，然后就会在一个远超数组长度的范围内开始循环
    // 最终访问越界
    for (i = 0; i <= length - 1; i++)
        result += a[i];
    return result;
}

// 修改之后：
float sum_elements(float a[], unsigned length) {
    float result = 0;
    for (unsigned i = 0; i < length; ++i) { result += a[i]; }
    return result;
}
```

## 练习题 2.26

> 现在给你一个任务，写一个函数用来判定一个字符串是否比另一个更长。前提是你要用字符串库函数 `strlen` ，它的声明如下：
>
> ```C
> /* Prototype for library funciton strlen */
> size_t strlen(const char* s);
> ```
>
> 最开始你写的函数是这样的：
>
> ```C
> /* Determine whether string s is longer than string t */
> /* WRANING: This function is buggy */
> int strlonger(char* s, char* t) {
>     return strlen(s) - strlen(t) > 0;
> }
> ```
>
> 当你在一些示例数据上测试这个函数时，一切似乎都是正确的。进一步研究发现在头文件 `stdio.h` 中数据类型 `size_t` 是定义成 `unsigned int` 的。
>
> A. 在什么情况下，这个函数会产生不正确的结果？

解答：

当字符串 `t` 的长度大于 `s` 的长度时，就会产生不正确的结果。

> B. 解释为什么会出现这样不正确的结果。

解答：

因为 `strlen` 函数返回的是无符号数，当两个无符号数运算时产生的结果也是无符号数，当运算结果为负数时就会产生不正确的计算结果。

> C. 说明如何修改这段代码好让它能可靠的工作。

解答：

```C
int strlonger(char* s, char* t) {
    if (strlen(s) < strlen(t)) return -1;
    else if (strlen(t) < strlen(s)) return 1;
    else return 0;
}
```

## 练习题 2.27

> 写出一个具有如下原型的函数：
>
> ```C
> /* Determin whether arguments can be added without overflow */
> int uadd_ok(unsigned x, unsigned y);
> ```
>
> 如果参数 `x` 和 `y` 相加不会产生溢出，这个函数就返回 `1` 。

解答：

```C
int uadd_ok(unsigned x, unsigned y) { return (x + y < x || x + y < y) ? 0 : 1; }
```

## 练习题 2.28

> 我们能用一个十六进制数字来表示长度 `w = 4` 的位模式。对于这些数字的无符号解释，使用等式（2.12）填写下表，给出所示数字的无符号加法逆元的位表示（用十六进制形式）。

解答：

```
x                   -u_4_x
十六进制    十进制    十进制     十六进制
0          0        0         0
5          5        11        B
8          8        8         8
D          13       3         3
F          15       1         1
```

## 练习题 2.29

> 按照图 2-25 的形式填写下表。分别列出 5 位参数的整数值、整数和与补码和的数值、补码和的位级表示，以及属于等式（2.13）推导中的哪种情况。

解答： 

```
-12[10100] -15[10001] -27[100101] 5[00101] 负溢出
-8[11000] -8[11000] -16[110000] -16[10000] 正常
-9[10111] 8[01000] -1[111111] -1[11111] 正常
2[00010] 5[00101] 7[000111] 7[00111] 正常
12[01100] 4[00100] 16[010000] -16[10000] 正溢出
```

## 练习题 2.30

> 写出一个具有如下原型的函数：
>
> ```C
> /* Determin whether arguments can be added without overflow */
> int tadd_ok(int x, int y);
> ```
>
> 如果参数 `x` 和 `y` 相加不会产生溢出，这个函数就返回 `1` 。

解答：

```C
int tadd_ok(int x, int y) {
    int ans = x + y;
    if (x > 0 && y > 0 || ans < 0) return 0;
    if (x < 0 && y < 0 || ans > 0) return 0;
    return 1;
}
```

## 练习题 2.31

> 你的同事对你补码加法溢出条件的分析有些不耐烦了，他给出了一个函数 `tadd_ok` 的实现，如下所示：
>
> ```C
> /* Determine whether arguments can be added without overflow */
> /* WARNING: This code is buggy */
> int tadd_ok(int x, int y) {
>     int sum = x + y;
>     return (sum - x == y) && (sum - y == x);
> }
> ```
>
> 你看了代码以后笑了。解释一下为什么。

解答：

补码加法会形成一个阿贝尔群，无论是否产生溢出， `(x + y) - y` 的答案总是 `x` 。

## 练习题 2.32

> 你现在有个任务，编写函数 `tsub_ok` 的代码，函数的参数是 `x` 和 `y` ，如果计算 `x - y` 不产生溢出，函数就返回 `1` 。假设你写的练习题 2.30 的代码如下所示：
>
> ```C
> /* Determine whether arguments can be subtracted without overflow */
> /* WARNING: This code is buggy */
> int tsub_ok(int x, int y) {
>        return tadd_ok(x, -y);
> }
> ```
>
> `x` 和 `y` 取什么值时，这个函数会产生错误的结果？

解答：

当 `x == TMAX && y == TMIN` 时，函数的输出会产生错误。

## 练习题 2.33

> 我们可以用一个十六进制数字来表示长度 `w = 4` 的位模式。根据这些数字的补码解释，填写下表，确定所示数字的加法逆元。

解答：

```
x                  -x
十六进制    十进制   十进制    十六进制
0          0       0        0
5          5       -5       B
8          -8      -8       8
D          -3      3        3
F          -1      1        1
```

## 练习题 2.34

> 按照图 2-27 的风格填写下表，说明不同的 3 位数字乘法的结果。

解答：

```
[100]4 [101]5 [010100]20 [100]4
[100]-4 [101]-3 [001100]12 [100]-4

[010]2 [111]7 [001110]14 [110]6
[010]2 [111]-1 [111110]-2 [110]-2

[110]6 [110]6 [100100]36 [100]4
[110]-2 [110]-2 [000100]4 [100]-4
```

