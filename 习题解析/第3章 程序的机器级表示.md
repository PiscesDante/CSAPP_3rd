# 第3章 程序的机器级表示

## 练习题 3.1

> 假设下面的值存放在指明的内存地址和寄存器中：
>
> ```
> 地址：[0x100] 值：[0xFF]
> 地址：[0x104] 值：[0xAB]
> 地址：[0x108] 值：[0x13]
> 地址：[0x10B] 值：[0x11]
> 
> 寄存器：[%rax] 值：[0x100]
> 寄存器：[%rcx] 值：[0x1]
> 寄存器：[%rdx] 值：[0x3]
> ```
>
> 填写下表，给出所示操作数的值：

解答：

```
操作数：[%rax] 值：[0x100]
操作数：[0x104] 值：[0xAB]
操作数：[$0x108] 值：[0x108]
操作数：[(%rax)] 值：[0xFF] # (%rax) 方式寻址
操作数：[4(%rax)] 值：[0xAB] # 4 + (%rax) = 4 + 0x100 = 0x104 方式为寻址
操作数：[9(%rax, %rdx)] 值：[0x11] # 9 + 0x100 + 0x003 = 0x10B 方式为寻址
操作数：[260(%rcx, %rdx)] 值：[0x13] # 206 + 0x1 + 0x3 = 0x104 + 0x1 + 0x3 = 0x108 方式为寻址
操作数：[0xFC(, %rcx, 4)] 值：[0xFF] # 0xFC + 0x04 = 0x100 方式为寻址
操作数：[(%rax, %rdx, 4)] 值：[0x11] # 0x100 + 4 * 0x003 = 0x10B 方式为寻址
```

## 练习题 3.2

> 对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。（ 例如， `mov` 可以被重写成 `movb` , `movw` , `movl` , `movq` ）

解答：

```
mov[l] %eax, (%rsp)
mov[w] (%rax), %dx
mov[b] $0xFF, %bl
mov[b] (%rsp, %rdx, 4), %dl
mov[q] (%rdx), %rax
mov[w] %dx, (%rax)
```

## 练习题 3.3

> 当我们调用汇编器的时候，下面代码的每一行都会产生一个错误消息。解释每一行都是哪里出了错。

解答：

```ASM
movb $0xF, (%ebx) ; 不能将立即数直接写入内存 
                   ; 改正：%ebx 中的内容不能进行寻址操作
movl %rax, (%rsp) ; movl 只能操作 32 位的源操作数，而 %rax 是 64 位的寄存器
movw (%rax), 4(%rsp) ; 不能将内存中的数据直接写入内存
movb %al, %sl ; 不存在 %sl 寄存器
movq %rax, $0x123 ; 不能以立即数作为目的操作数
movl %eax, %rdx ; movl 不能对 64 位的 %rdx 进行操作
movb %si, 8(%rbp) ; movb 不能对 16 位的 %si 进行操作
```

## 练习题 3.4

> 假设变量 `sp` 和 `dp` 被声明为类型
>
> ```
> src_t*  sp;
> dest_t* dp;
> ```
>
> 这里……

解答： 

TODO：这个题的解答有问题，需要继续研究

```ASM
;sp -> %rdi
;dp -> %rsi

;long -> long :
	movq (%rdi), %rax
	movq %rax, (%rsi)
;char -> int :
	mov (%rdi), %eax
	movq %eax, (%rsi)
;char -> unsigned :
	movq (%rdi), %eax
	movq %eax, (%rsi)
;unsigned char -> long :
	movzwq (%rdi), %rax
	movq %rax, (%rsi)
;int -> char :
	movq (%rdi), %al
	movq %al, (%rsi)
;unsigned -> unsigned char :
	movq (%rdi), %al
	movq %al, (%rsi)
;char ->short :
	movq (%rdi), %ax
	movq %ax, (%rsi)
```

## 练习题 3.5

> 已知信息如下。将一个原型为
>
> `void decode1(long* xp, long* yp, long* zp);`
>
> 的函数编译成汇编代码，得到如下代码：
>
> ```ASM
> ;void decode1(long* xp, long* yp, long* zp)
> ;xp in %rdi, yp in %rsi, zp in %rdx
> decode1:
> 	movq (%rdi), %r8 ; *xp -> %r8
> 	movq (%rsi), %rcx ; *yp -> %rcx
> 	movq (%rdx), %rax ; *zp -> %rax
> 	movq %r8, (%rsi) ; %r8 -> *yp
> 	movq %rcx, (%rdx) ; %rcx -> *zp
> 	movq %rax, (%rdi) ; %rax -> *xp
> 	ret
> ```
>
> 请写出等效于上面汇编代码的 `decode1` 的 C 代码。

解答：

```C
void decode1(long* xp, long* yp, long* zp) {
    // *xp->*yp; *yp->*zp; *zp->xp
    long temp = *xp;
    *xp = *zp;
    *zp = *yp;
    *yp = temp;
}
```

## 练习题 3.6

> 假设寄存器 `%rax` 的值为 `x` ， `%rcx` 的值为 `y` 。填写下表，指明下面每条汇编代码指令存储在寄存器 `%rdx` 中的值：

解答：

```
表达式：[leaq 6(%ax), %rdx] 结果：[6 + x]
表达式：[leaq (%rax, %rcx), %rdx] 结果：[x + y]
表达式：[leaq (%rax, %rcx, 4), %rdx] 结果：[x + y * 4]
表达式：[leaq 7(%rax, %rcx, 8), %rdx] 结果：[7 + x + y * 8]
表达式：[leaq 0xA(, %rcx, 4), %rdx] 结果：[10 + y * 4]
表达式：[leaq 9(%rax, %rcx, 2), %rdx] 结果：[9 + x + y * 4]
```

## 练习题 3.7

> 考虑下面的代码，我们省略了被计算的表达式：
>
> ```C
> long scale2(long x, long y, long z) {
>    	long t = /*      Missing      */;
>    	return t;
> }
> ```
>
> 用 GCC 编译实际的函数得到如下的汇编代码：
>
> ```ASM
> ; long scale2(long x, long y, long z)
> ; x in %rdi, y in %rsi, z in %rdx
> scale2:
> 	leaq (%rdi, %rdi, 4), %rax ; 5 * %rdi -> %rax
> 	leaq (%rax, %rsi, 2), %rax ; %rax + %rsi * 2 -> %rax
> 	leaq (%rax, %rdx, 8), %rax ; %rax + %rdx * 8 -> %rax
> 	ret
> ```
>
> 填写出 C 代码中缺失的表达式。

解答：

```C
// 5x -> %rax
// 5x + 2y -> %rax
// 5x + 2y + 8z -> %rax
long scale2(long x, long y, long z) {
    long t = 5 * x + 2 * y + 8 * z;
    return t;
}
```

## 练习题 3.8

> 假设下面的值存放在制定的内存地址和寄存器中：
>
> ```
> 地址：[0x100] 值：[0xFF]
> 地址：[0x108] 值：[0xAB]
> 地址：[0x110] 值：[0x13]
> 地址：[0x118] 值：[0x11]
> 
> 寄存器：[%rax] 值：[0x100]
> 寄存器：[%rcx] 值：[0x001]
> 寄存器：[%rdx] 值：[0x003]
> ```
>
> 填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值：

解答：

```
指令：[addq %rcx, (%rax)]
目的：[将 %rcx 中的值加到 %rax 指向的内存中]
值：[0x100]

指令：[subq %rdx, 8(%rax)]
目的：[将 %rax 指向的地址加 8 然后将里面的值减去 %rdx 中存储的值]
值：[0xA8]

指令：[imulq $16, (%rax, %rdx, 8)]
目的：[将 %rax + %rdx * 8 地址中的值乘以 16]
值：[0x110]

指令：[incq 16(%rax)]
目的：[将 16 + %rax 地址中的值加 1]
值：[0x14]

指令：[decq %rcx]
目的：[将 %rcx 中的值减去 1]
值：[0x0]

指令：[subq %rdx, %rax]
目的：[%rax 中的值减去 %rdx 中的值]
值：[0x0FD]
```

## 练习题 3.9

> 假设我们想生成以下 C 函数的汇编代码：
>
> ```C
> long shift_left4_rightn(long x, long n) {
>        x <<= 4;
>        x >>= n;
>        return x;
> }
> ```
>
> 下面这段汇编代码执行实际的位移，并将最后的结果放在寄存器 `%rax` 中。此处省略了两条关键指令。参数 `x` 和 `n` 分别存放在寄存器 `%rdi` 和 `%rsi` 中。
>
> ```ASM
> ; long shift_left4_rightn(long x, long n)
> ; x in %rdi, n in %rsi
> shift_left4_rightn:
> 	movq %rdi, %rax ; Get x
> 	~~~~~~~~~~~~~~~ ; x <<= 4
> 	movl %esi, %ecx ; Get n (4 bytes)
> 	~~~~~~~~~~~~~~~ ; x >>= n
> ```
>
> 根据右边的注释，填出缺失的指令。请使用算术右移操作。

解答：

```ASM
; long shift_left4_rightn(long x, long n)
; x in %rdi, n in %rsi
shift_left4_rightn:
	movq %rdi, %rax ; Get x
    salq $0x4, %rax  ; x <<= 4
	movl %esi, %ecx ; Get n (4 bytes)
	sarq %ecx, %rax  ; x >>= n
```

## 练习题 3.10

> 下面的函数是图 3-11a 中函数的一个变种，其中有些表达式用空格替代：
>
> ```C
> long arith2(long x, long y, long z) {
>     long t1 = ~~~~~~~~~~~~;
>     long t2 = ~~~~~~~~~~~~;
>     long t2 = ~~~~~~~~~~~~;
>     long t4 = ~~~~~~~~~~~~;
>     return t4;
> }
> ```
>
> 实现这些表达式的汇编代码如下：
>
> ```ASM
> ; long arith2(long x, long y, long z)
> ; x in %rdi, y in %rsi, z in %rdx
> 
> arith2:
>     orq %rsi, %rdi
>     sarq $3, %rdi
>     notq %rdi
>     movq %rdx, %rax
>     subq %rdi, %rax
>     ret
> ```
>
> 基于这些汇编代码，填写 C 语言代码中缺失的部分。

解答：

```C
long arith2(long x, long y, long z) {
    long t1 = x | y;
    long t2 = x >> 3;
    long t3 = ~x;
    long t4 = z - x;
    return t4;
}
```

## 练习题 3.11

> 常常可以看见以下形式的汇编代码行：
>
> `xorq %rdx, %rdx`
>
> 但是在产生这段汇编代码的 C 代码中，并没有出现 EXCLUSIVE-OR 操作。
>
> A. 解释这条特殊的 EXCLUSIVE-OR 指令的效果，它实现了什么有用的操作。
>
> B. 更直接的表达这个操作的汇编代码是什么？
>
> C. 比较同样一个操作的两种不同实现的编码字节长度。

解答：

A.  异或的运算结果是，若两位一样则为 0 否则为 1。那么这个指令的操作就是将 `%rdx` 寄存器清零。

B. 更加直接的汇编代码是： `movq $0 %rdx` 。

C. TODO

## 练习题 3.12

> 考虑如下函数，它计算两个无符号 64 位数的商和余数：
>
> ```C
> void uremdiv(unsigned long x, unsigned long y,
>               unsigned long* qp, unsigned long* rp) {
>    	unsigned long q = x / y;
>    	unsigned long r = x % y;
>    	*qp = q;
>    	*rp = r;
> }
> ```
>
> 修改有符号除法的汇编代码来实现这个函数。

解答：

TODO

## 练习题 3.15

> 在下面这些反汇编二进制代码节选中，有些信息被 X 代替了。回答下列关于这些指令的问题。

解答：

A. 下面 `je` 指令的目标是什么？（在此，你不需要知道任何有关 `callq` 指令的信息。）

```
4003FA: 74 02 | je [4003FC]
4003FC: FF D0 | callq *%rax
是以下一条指令作为基准进行计算
```

B. 下面 `je` 指令的目标是什么？

```
40042F: 74 F4 | je [400525]
400431: 5D    | pop %rbp
```

C. `ja` 和 `pop` 指令的地址是多少？

```
[400543]: 77 02 | ja 400547 ; ja 的编码需要两个字节
[400545]: 5D    | pop %rbp
```

D. 在假面的代码中，跳转目标的编码是 PC 相对的，且是一个 4 字节补码数。字节按照从最低位到最高位的顺序列出，反映出 x86-64 的小端法字节顺序。跳转目标的地址是什么？

```
4005E8: e9 73 FF FF FF | jmpq [400560]
4005ED: 90             | nop
```

PC 相对的地址是小端法，也就是 `0xFFFFFF73` 以补码解读，解得 `-141` 也就是以下一条指令的地址加上这个偏置值。即： `0x4005ED + (-141) = 0x400560` 。

## 练习题 3.16

> 已知下列 C 代码：
>
> ```C
> void cond(long a, long* p) {
>  if (p && a > *p)
>    	*p = a;
> }
> ```
>
> GCC 会产生下面的汇编代码：
>
> ```ASM
> ; void cond(long a, long* p);
> ; a in %rdi, p in %rsi
> cond:
>     testq %rsi, %rsi
>     je .L1
>     cmpq %rdi, (%rsi)
>     jge .L1
>     movq %rdi, (%rsi)
> .L1
>     rep ;ret
> ```
>

> A. 按照图 3-16b 中所示的风格，用 C 语言写一个 `goto` 版本，执行同样的计算，并模拟汇编代码的空直流。像示例中那样给汇编代码加上注解可能会有所帮助。

解答：

```C
void cond(long a, long* p) {
	if (p && a > *p) goto replacing;
    return;
replacing:
    *p = a;
    return;
}
```

> B. 请说明为什么 C 语言代码中只有一个 `if` 语句，而汇编代码中包含两个分支。

解答：

因为一个 `if` 就会产生两个分支，即「执行 `if` 语句」 和 「不执行 `if` 语句」。

## 练习题 3.17

> 将 `if` 语句翻译成 `goto` 代码的另一种可能的规则如下：
>
> ```
> t = test-expr;
> if (t)
>     goto true;
> else-statement
>     goto done;
> true:
> 	then-statement
> done:
> ```

> A. 基于这种规则，重写 `absdiff_se` 的 `goto` 版本。

解答：

```C
long lt_cnt = 0;
long ge_cnt = 0;

long absdiff_se(long x, long y) {
    long result;
    if (x < y) goto label_true;
    ge_cnt += 1;
    result = x - y;
    goto label_done;
label_true:
    lt_cnt += 1;
    result = y - x;
label_done:
    return result;
}
```

> B. 你能想出选用一种规则而不选用另一种规则的理由吗？

解答：

我会选用 A 中的写法。因为程序的结构比较容易进行阅读。

## 练习题 3.18

> GCC 产生如下的汇编代码：
>
> ```ASM
> ; long test(long x, long y, long z)
> ; x in %rdi, y in %rsi, z in %rdx
> 
> test:
> 	leaq (%rdi, %rsi), %rax ; 将 x + y 存入 %rax
> 	addq %rdx, %rax ; 将 x + y 加上 z 存入 %rax
> 	
> 	cmpq $-3 %rdi ; if x >= -3
> 	jge .L2 ; 跳转至 .L2
> 	cmpq %rdx, %rsi ; if y >= z
> 	jge .L3 ; 跳转至 .L3
> 	movq %rdi, %rax ; 将 x 移动至 %rax
> 	imulq %rsi, %rax ; 将 y * x 存入 %rax
> 	ret ; 返回
> .L3:
> 	movq %rsi, %rax ; 将 y 拷贝进 rax
> 	imulq %rdx, %rax ; 将 y * z 拷贝进 rax
> 	ret ; 返回
> .L2:
> 	cmpq $2, %rdi ; 比较 x 同 2 : x <= 2
> 	jle .L4 ; 跳转至 .L4
> 	movq %rdi, %rax ; 将 x 存入 rax
> 	imulq %rdx, %rax ; 将 x * z 存入 rax
> .L4:
> 	rep ; 返回
> ```
>
> 填写代码中缺失的表达式。

解答：

```C
long test(long x, long y, long z) {
    long val = x + y + z; // right
    if (x >= -3) { // x < -3
        if (x <= 2) { // y < z
            val = x * y; // right
        } else {
            val = x * z; // y * z
        }
    } else if (y >= z) { // x > 2
        val = y * z; // x * z
    }
    return val;
}
```