# 第2章 信息的表示和处理

二值信号能很容易的被表示、存储和传输。

当把位组合在一起，再加上某种解释，即赋予不同的可能的位模式的含义，就能表示任何有限集合的元素。

* **无符号** 编码基于传统的二进制表示法，表示大于等于零的数字。
* **补码** 编码是表示 **有符号整数** 的最常见的方式，有符号整数就是可以为正或者为负的数字。
* **浮点数** 编码是表示实数的科学记数法的以 `2` 为基数的版本。

当结果太大以至于不能表示数字时，某些运算结果就会 **溢出** 。

整数运算和浮点数运算会有不同的数学属性是因为 **它们处理数字表示有限性的方式不同** 。整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的。而浮点数虽然可以编码一个较大的数值范围，但这种表示只是 **近似的** 。

## 2.1 信息存储

大多数计算机使用 `8` 位的块。或者 **字节（byte）** 。作为最小的可寻址的内存单位，而不是单独的 **位（bit）** 。机器级程序将内存视为一个巨大的 **字节数组** ，称为 **虚拟内存** 。内存的每一个字节都有一个唯一的数字来标识，称为它的 **地址** ，所有可能的地址的集合就称为 **虚拟地址空间** 。

C 语言中的一个指针的值 就是 **某个存储块的第一个字节的虚拟地址** 。

实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单的视为一个字节块，而程序本身就是个字节序列。

指针也有两个方面：**值** 和 **类型** 。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的类型。

### 2.1.1 十六进制表示法

以 `16` 为基数，或者叫做 **十六进制数** ，来表示位模式。十六进制（ Hexadecimal ）使用数字 `0 ~ 9` 以及字符 `A ~ F` 来表示 16 个可能的值。

在 C 语言中，以 `0x` 或者 `0X` 开头的数字常量被认为是十六进制的字面值。

编写机器级程序的一个常见任务就是在进制之间进行人工转换。

二进制转换为十六进制：如果给定一个二进制数字，可以通过首先把这个二进制字符串分为每 4 个一组来转换为十六进制。不过要注意，如果二进制串的位数不是 4 的倍数，最左边的一组可以少于 4 位，然后前面用 `0` 补足。

十进制和十六进制表示之间的转换需要使用乘法或者除法来处理一般的情况。

### 2.1.2 字数据大小

每台计算机都有一个 **字长** ，指明 **指针** 数据的标称大小。因为虚拟地址是以这样一个字来编码的，所以字长决定的最重要的系统参数就是 **虚拟地址空间的最大大小** 。对于一个字长为 $w$ 位的机器而言，虚拟地址的范围是 $0$ ~ $2^{w} - 1$ ,程序最多访问 $2^{w}$ 个字节。

大多数 64 位机器也能运行 32 位机器编译的程序，这是一种向后兼容。

我们将程序称为 **`XX` 位程序** ，区别在于该程序是如何编译的，而不是其运行的机器类型。

使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。可移植性的一个方面就是使程序对于不同的数据类型的数据大小不敏感。

### 2.1.3 寻址和字节顺序

在几乎所有的机器上，多字节对象都被存储为连续的 **字节序列** ，对象的地址为所使用的字节中最小的地址。

某些机器选择在内存中按照从 **最低有效字节到最高有效字节的顺序存储对象** ，而另一些机器则按照从 **最高有效字节到最低有效字节的顺序存储对象** 。<u>前一种规则， **最低有效字节在最前面** 的方式，称为 **小端法** 。后一种规则， **最高有效字节在最前面** 的方式，称为 **大端法**</u> 。

大多数 Intel 兼容机都只使用 **小端** 模式。然而实际情况是： **一旦选择了特定的操作系统，那么字节顺序也就固定下来了** 。

**反汇编器** 是一种确定可执行程序文件所表示的指令序列的工具。

当阅读小端法机器生成的机器级程序表示时，经常会将字节序列按照相反的顺序显示。书写字节序列的自然方式是最低位有效字节在左边，而最高有效字节在右边，这正和自然的书写顺序相反。

运算符 `sizeof` 来确定对象使用的字节数。表达式 `sizeof(Typename)` 返回存储一个类型为 `Typename` 的对象所需要的字节数。使用 `sizeof` 而不是一个固定的数值，是为了保证可移植性。

尽管浮点型和整型都是对数值 `12345` 进行编码，但是它们的编码方式截然不同。

**强制类型转换运算符可以将一种数据类型转换为另一种** 。

### 2.1.4 表示字符串

十进制数字 `x` 的 `ASCII` 码正好是 `0x3x` ，而终止字节的十六进制表示为 `0x00` 。在使用 `ASCII` 码作为字符码的任何系统上字符串都将表示相同的内容。

### 2.1.5 表示代码

不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

从机器角度来看，程序仅仅是字节序列。

### 2.1.6 布尔代数

### 2.1.7 C 语言中的位级运算

### 2.1.8 C 语言中的逻辑运算

逻辑运算认为所有的非零参数都表示 `TRUE` ，而参数 `0` 表示 `FALSE` 。它们返回 `1` 或者 `0` ，分别表示结果为 `TRUE` 或者 `FALSE` 。

按位运算只有在特殊情况下，也就是参数被限制为 `0` 或者 `1` 时，才和与其对应的逻辑运算有相同的行为。

逻辑运算执行 **短路** 操作，逻辑与 和 逻辑或 只要对第一个参数求值就能确定整个表达式的值的话，就不会对第二个参数求值。

### 2.1.9 C 语言中的位移运算

位移运算分为 **向左** 或者 **向右** 移动位模式。

**左位移运算（ `x << k` ）** 移动 `k` 位，丢弃最高的 `k` 位，并且在右端补上 `k` 个 `0` 。

**右位移运算（ `x >> k` ）** 支持两种方式的右移：

* **逻辑右移** ：在左端补上 `k` 个 `0` 。
* **算术右移** ：在左端补上 `k` 个 **最高有效位** 。

C 语言标准并没有明确定义对于有符号数应该使用哪一种类型的右移。然而实际上，几乎所有的编译器和机器都 <u>对有符号数使用 **算术右移**</u> 。

**对于无符号数，必须使用逻辑右移** 。

## 2.2 整数表示

### 2.2.5 C 语言中的有符号数与无符号数

虽然 C 标准没有精确规定应该如何进行这种转换，但是大多数系统遵循的原则时底层的位序列保持不变。因此，数据类型转换的本质就是 **位序列的解释方式发生变化** 。

由于 C 语言对同时包含有符号数和无符号数表达式的这种处理方式，出现了一些奇特的行为。 **<u>当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么 C 语言会隐式的将有符号参数强制转换为 「无符号参数」 ，并且将这两个数都以无符号方式来解释，然后执行这个运算</u>** 。

### 2.2.7 截断数字

假设我们不使用额外的位来扩展一个值，而是减少表示一个数字的位数。比如：

```C
int x = 53191;
short sx = (short)x; // -12345
int y = sx; // -12345
```

当我们将 `x` 强制类型转换为 `short` 时，我们就将 32 位的 `int` 截断为了 16 位的 `short int` 。

我们现在可以看到这个 16 位位模式就是 `-12345` 的补码表示。再将其强制转换到 `int` 时，符号扩展把高 16 位设置为 `1` ，从而生成了 `-12345` 的 32 位补码。

* 截断无符号数是从高位开始进行截断。
* 截断有符号数（补码）也是从高位开始截断。

## 2.3 整数运算

### 2.3.1 无符号加法

#### 原理：检测无符号数加法中的溢出

对在范围 $0 \le x, y \le U_{max}$ 的 $x$ 和 $y$ ，令 $s = x + y$ ，当且仅当： $s \le x$ 或 $s \le y$ 时，运算发生了溢出。



### 2.3.2 补码加法



### 2.2.8 关于有符号数与无符号数的建议

有符号数到无符号数的隐式强制类型转换将导致很多非直观的行为。并且这些错误会很难发现。

## 2.4 浮点数

浮点表示对形如 $V = x \times 2^{y}$ 的有理数进行编码。所有的计算机都支持 **`IEEE` 浮点** 标准。

舍入： **当一个数字不能被准确的表示为这种格式时，就必须 向上调整 或者 向下调整** 。

### 2.4.1 二进制小数

**数字权** 的定义与小数点相关： **小数点左边数字的权是 10 的正幂，得到整数值；而小数点右边数字的权是 10 的负幂，得到小数值** 。在十进制中，小数点向左移动 1 位代表数字除以 10，向右移动 1 位代表数字乘以 10 。

同样的，对于二进制小数，二进制小数点向左移动 1 位代表该数字除以 2 ；向右移动 1 位代表乘以 2 。

形如 $0.111...11_{2}$ 的数表示的是刚好小于 1 的数。我们使用 $1.0 - \epsilon$ 来表示这样的数。

### 2.4.2 `IEEE` 浮点表示

通过给定 $x$ 和 $y$ 的值，来表示形如 $x + 2^{y}$ 的数字。

`IEEE` **浮点标准** 使用 $V = (-1)^{s} \times M \times 2^{E}$ 的形式来表示一个数：

* **符号（ $sign$ ）** ：$s$ 决定这个数的正负，当 $s = 1$ 为 负，$s = 0$ 为 正。**对于数值 $0$ 的符号位解释作为特殊情况处理** 。
* **尾数（ $significand$ ）** ： $M$ 是一个二进制小数，范围是 $[1, 2 - \epsilon]$ 或 $[0, 1 - \epsilon]$ 。
* **阶码（ $exponent$ ）** ： $E$ 的作用是对浮点数加权，这个权重是 $2^{E}$ （可能为负）。

**将浮点数的位表示划分为三个字段，分别对这些值进行 编码** ：

* 符号 $s$ ：一个单独的符号位 `s` 直接编码。
* 阶码 $E$ ：`k` 位的阶码字段 `exp = e(k-1)e(k-2)...e(0)` 。
* 尾数 $M$ ：`n` 位小数字段 `frac = f(n-1)f(n-2)f(0)` 。

根据 `exp` 的值，被编码的值可以分成三种不同的情况：

#### 情况 1：规格化的值

* **条件** ：<u>当 `exp` 的 位模式 **不全为 `0`** ，也 **不全为 `1`**</u> 。
* **阶码字段的解释** ：以 **偏置（ $biased$ ）** 形式表示的 有符号数。

这种情况下，**阶码** $E$ 是 $exp - Bias$ 。其中 $exp$ 是 **无符号数** ，位表示就是 **阶码字段** 。而 $Bias$ 是一个等于 $2^{k-1} - 1$ 的 **偏置值** 。

小数字段 `frac` 被解释为一个 **二进制小数值 $f$** 。其中 $f\in[0,1)$ 。也就是二进制小数点在最高有效位的左边。 **尾数** $M$ 定义为 $1 + f$ 。

也就是说，**在情况1，这个规格化的数值下，表示的是一个有符号数，并且科学记数法的小数部分永远都是 $1.StringOf(0, 1)$ 。然后通过阶码的值 $E$ 来左右移动小数点，最后变成一个有理数真值的二进制小数近似表示** 。

#### 情况 2：非规格化的值

* **条件** ：当 **阶码字段** 全为 `0` 时，所表示的数字就是 **非规格化形式** 。
* 这时阶码的值 $E$ 是 $1 - Bias$ 。
* 尾数 $M$ 的值就是 $f$ ，没有加 $1$ 。

非规格化数的两个用途：

* 提供了一种表示数值 $0$ 的方法。
* 表示那些非常接近于 $0$ 的数。

#### 情况 3：特殊值

* 当 **阶码字段 `exp`** 全为 `1` 时：
    + 当 `frac` 全部为 `0` 时，表示 **无穷** ： `s` 为 `0` 时 **正无穷** ， `s` 为 `1` 时 **负无穷** 。
    + 当 `frac` 非零，表示结果为 `NaN` 。
