# Lecture 10. Program Optimization

## 今日话题

这一章的主题是：如何让程序运行的更快？

*   总览
*   通用有效的优化方式
    *   代码移动（这种优化是把需要执行多次但计算结果不会改变的计算移到前面）/预先计算；
    *   强度削减（将函数调用等黑盒操作移出循环等等）；
    *   共享通用的子表达式（避免重复计算）；
    *   移除不必要的过程调用；
*   阻止编译器对代码进行优化的情况
    *   过程调用；
    *   内存别名；
*   利用指令级的并行；
*   处理条件表达式；

## 性能的真相

>   除了渐进时间复杂度还有更多的东西需要关注。

*   常量也非常重要！
    *   如何撰写代码将带来十倍以上的性能差异；
    *   必须在多个层面进行优化：算法，数据表示，过程和循环；
*   为了优化性能必须理解操作系统是如何工作的
    *   程序是如何编译以及执行的；
    *   现代处理器和内存系统是如何协同工作的；
    *   如何度量程序的性能从而定位瓶颈的；
    *   如何在避免大规模重构的基础上来提升程序的性能；

我们使用的编译器是 GCC 。

## 编译器应当做的优化

*   为机器提供程序的有效映射

    *   寄存器的分配；
    *   代码的选择和排列；
    *   移出无用的代码；
    *   对一些小的低效代码作出改进；

*   不要（经常的）去尝试提升渐进效率

    *   让程序员决定选择什么样的算法；
    *   虽然渐进复杂度中的常量也非常重要，但是对于大 O 的改进有限，显然改进最高次项更加有效率；

*   克服「优化障碍」非常困难

    *   潜在的内存别名；
    *   潜在的过程副作用；

编译器很难理解内存引用模式和过程调用的影响。

## 编译器能做的优化是有限的

*   操作被在很基础的层面加以限制
    *   禁止对程序的行为作出任何改变（当程序可能使用了不标准的语言特性时除外）；
    *   对于一些无道理的行为不做任何的优化。
*   一些被程序员在语言或者风格方面刻意混淆或者不符常理的行为将不被优化（比如说数据范围可能会比正常情况下要小，这个地方看不太懂）；
*   很多分析仅仅关注当前的过程
    *   对程序进行整体的分析将付出巨大成本；
    *   新版的 GCC 可能会对整个文件进行分析，但也仅此而已；
*   大多数分析仅仅局限于静态信息
*   **<u>当犹豫是否对程序进行优化时，编译器总是选择不优化</u>** 。

## 通用的有效优化措施

一些独立于编译器和处理器的优化手段：

*   代码移动，这种优化是把需要执行多次但计算结果不会改变的计算移到前面。
    *   如果一些操作每次都将得到相同的结果；
    *   尤其是将代码移出循环体；

```C
void set_row(double* a, double* b, long i, long n)
{
    long j;
    for (j = 0; j < n; ++j) {
        a[n * i + j] = b[j]; /* 这里可以将 n * i 移出循环 */
    }
}

/* 改进后： */
void set_row(double* a, double* b, long i, long n)
{
    long j;
    long ni = n * i;
    for (j = 0; j < n; ++j) {
        a[ni + j] = b[j]; /* 这里可以将 n * i 移出循环 */
    }
}
```

## 削减计算强度

*   使用简单地计算方式来代替复杂的计算方式；
*   使用位移，加减来代替乘法和除法： `16 * x ---> x << 4;` ；当然这个举动是依赖于机器本身的，一般的英特尔机器乘法需要 3 个时钟周期；

```C
/* 改进前 */
for (i = 0; i < n; ++i) {
    int ni = n * i;
    for (j = 0; j < n; ++j) {
        a[ni + j] = b[j];
    }
}

/* 改进后 */
int ni = 0;
for (i = 0; i < n; ++i) {
    for (j = 0; j < n; ++j) {
        a[ni +j] = b[j];
    }
    ni += n;
}
```

## 共享通用的子表达式

*   重用可以重用的部分表达式；
*   GCC 会在优化强度为 `-O1` 时进行这一步优化。

## 优化的绊脚石 #1 ：过程调用 #

```C
void lower(char* s)
{
    size_t i;
    /* strlen() 函数的调用对于编译器来说是个黑盒 */
    for (i = 0; i < strlen(s); ++i) {
        if (s[i] >= 'A' && s[i] <= 'Z') {
            s[i] -= ('A' - 'a');
        }
    }
}
```

这个函数的问题在于 `strlen` 的实现也是一个时间复杂度为 $O(n)$ 的过程（遍历整个字符串直到找到空字符为止），于是，对于长度为 `n` 的字符串来说，`lower` 函数的时间复杂度是 $O(n^2)$ 。当字符串的长度到达 500000 时，这个函数的性能将下降的非常严重。

## 提升性能的方法

```C
void lower(char* s)
{
    size_t length_s = strlen(s);
    short distance = ('A' - 'a');
    for (size_t i = 0; i < length_s; ++i) {
        if (s[i] >= 'A' && s[i] <= 'Z') {
            s[i] -= distance;
        }
    }
}
```

*   将 `strlen` 函数调用移出循环体；
*   因为函数调用的结果并不随循环而变化；
*   以上就是代码移动的策略；

经过以上的改造之后，整个函数的时间复杂度降为 $O(n)$ 。

## 优化的绊脚石：过程调用

*   为什么编译器不能直接将 `strlen` 移出循环？
    *   过程也许有副作用：在每次调用的时候改变全局状态；
    *   函数或者过程在每次调用之后不一定会返回相同的值：也许这个过程依赖于其他全局状态；也许主调函数和被调函数会产生一定程度的互动；
*   警告：
    *   编译器将过程视为一个黑盒（不能对其作出任何假设）；
    *   对这种黑盒的优化非常有限；
*   改进：
    *   使用内联函数；
    *   自己在 C 代码中做代码移动的工作；

## 内存相关问题

```C
/* SUM ROWS IS OF N * N MATRIX A
 * AND STORE IN VECTOR B*/
void sum_rows1(double* a, double* b, long n)
{
    for (int i = 0; i < n; ++i) {
        b[i] = 0;
        for (int j = 0; j < n; ++j) {
            b[i] += a[n*i + j];
            /* 该语句有两点需要优化：
             * 首先将 n * i 移出内循环；
             * 其次将 b[i] 的赋值操作移出内循环；*/
        }
    }
}
```

*   代码在每一次迭代中都会更新 `b[i]` ；
*   为什么编译器无法对这个问题进行优化？
    *   解答：因为 `b[i]` 和 `a[n*i + j]` 可能指向同一块内存。这种情况被称为别名。编译器必须假设这两个名字指向同一块内存。

```C
/* 对以上程序进行优化 */
void sum_rows2(double* a, double* b, long n)
{
    for (int i = 0; i < n; ++i) {
        long sum_of_current_row = 0;
        long current_row = n * i;
        for (int j = 0; j < n; ++j) {
            sum_of_current_row += a[current_row + j];
        }
        b[i] = sum_of_current_row;
    }
}
```

编译器无法对这种情况进行优化，因为它无法知晓当前使用的名称是否指向同一块内存（有内存别名的现象）。

## 优化的绊脚石：内存别名

*   内存别名：
    *   两个不同的寄存器还是内存中的地址指向同一个内存区块；
    *   这种情况在 C 语言中非常容易发生，因为：地址可以进行计算，并且可以直接访问内存区域；
    *   合理利用局部变量：比方说循环中的累加；这样可以告诉编译器不要在乎内存别名的事情；

## 利用指令级的并发

*   这需要对现代处理器的设计有一定的了解；
    *   硬件可以同时执行多个指令；
*   性能受到数据依赖的影响；
*   简单地重构可能会导致戏剧性的性能提升
    *   但是编译器经常不会完成上述简单地重构；
    *   当浮点数运算中缺少结合律和分配律时；

## 标准案例：向量的数据类型

```C
/* data structure for vectors */
typedef struct {
    size_t len;
    data_t* data;
} vec;
```

*   数据类型：如果这个 `data_t` 分别为 `int, long, float, double` 时会对性能有什么样的影响。

```C
/* retrieve vector element and store at val */
int get_vec_element(vec* v, size_t index, data_t* val)
{
    if (index > v->len) {
        return 0; /* FAIL */
    } else {
        *val = data[index];
        return 1; /* SUCCESS */
    }
}
```

用上面的例程来获取指定的元素，来计算数据结构中的所有元素的和；

## 每个元素所用的时钟周期

*   这个方法可以很方便的表示一个操作数组或者列表的程序的性能；
*   `Length = n` ；
*   在我们的方法中：CPE = cycle per element ；
*   $Time = CPE \times n + Overhead$ ；

得到的时间函数是一个一次函数，这个函数的斜率受数据类型的影响。而我们关注的核心也是函数的斜率。

## 最基础的优化手段

*   将过程调用移出循环体；
*   避免在每一个周期内都进行边界检查；
*   累加操作得到的值存储在局部变量中；

## 基础优化的效果

基础优化会有很好的效果，甚至能将时间降低 10 倍以上；

## 现代处理器设计

处理器将尽可能的将更多的指令读进来，然后将指令拆开，如果发现一些独立性较强的指令，那么就先执行这些指令。

现代处理器分为两部分，一部分用于控制（负责读入指令，安排指令的执行），一部分用于计算（单纯进行计算操作）。

总的来说，基本思想就是将程序的操作进行拆分，重组。使基本单元尽可能的保持繁忙。

## 超标量处理器

*   定义： **<u>一个超标量处理器能在一个时钟周期内检查并且执行多条指令</u>** 。这些指令经常获取自一个动态管理的，序列化的指令流。
*   优势：在不用刻意编写并行程序的情况下，超标量处理器可以带来指令级并行的好处；
*   大多数现代处理器都是超标量处理器；
*   第一颗超标量处理器是 1993 年的奔腾处理器；奔腾 Pro 是现代处理器的基础。

## 流水线功能单元

流水线的基本思想是将计算分解为一系列不同的阶段；可以认为每个阶段都有一个专用的硬件来处理计算任务，然后就可以做流水线的计算。

## Haswell 架构处理器

指令有两个参数：

*   延迟（ Latency ）：一个指令从头到尾需要多长时间；
*   由于流水线操作，参数周期（ Cycle ）表示两个小步骤之间的距离；

乘法和除法操作不能使用流水线，并且占据很长的时钟周期。在大多数机器上，除法是一项非常昂贵的操作。

## 循环展开（2 × 1）？？？

循环展开的基本思想就是：在循环中计算多个值，而不是一个值。

>   这个地方感觉听不太懂……可能需要课本的补充。

循环展开可以将 CPE 极大的降低。

## 关于分支的问题

### 挑战

*   指令控制单元必须在指令执行单元做好一切工作，使得有足够的操作让执行单元保持忙碌。
*   但是如果遇到条件分支，指令控制单元该怎么办？如何在保证正确性的前提下，不会让计算单元产生空闲。

这里采用的策略就是所谓的「分支预测」，基本思想就是「猜」。猜测哪个分支会被执行，然后执行，一旦猜错就会付出高昂代价（退回到 N 个时钟周期之前重新执行）。

## 获得高性能的关键

*   使用良好的编译器系统；
*   别做傻事：
    *   当心隐藏的低效算法；
    *   撰写编译器友好的代码：比方说注意「过程调用」以及「内存别名」的问题，这些部分出了问题，编译器一般都无法进行优化。
    *   仔细检查内层循环：这里一般都是核心工作所在的区域。
*   为硬件调教代码：
    *   利用指令级的并行功能；
    *   避免使用不可预测的分支；
    *   撰写缓存友好的代码（以后的课程会详解）。

