# Lecture 5. Machine Level Programming I: Basics

实际上有两种形式的「机器程序」，首先是在计算机上运行的目标代码（目标代码是一串字节，这串字节序列编码处理需要执行的指令）；

当说起「机器代码」时，有时指的是由字节序列组成的「目标代码」，有时指的是文本格式的「汇编代码」。这两个是一一映射的。本质上是一个东西，只不过表现形式不同。

## 今天：机器级编程（甲）：基础

* 英特尔处理器以及处理器架构的历史；
* C， 汇编以及机器码；
* 汇编基础：寄存器，操作数，移动；
* 算术 & 逻辑操作符；

## 英特尔 x86 处理器

* 几乎统治了笔记本，台式机和服务器的市场；
* 革命性的架构设计
    * 发迹于 1978 年，在 8086 时代具有竞争力；
    * 随着时间的推移，加入了越来越多的新特性；
* 复杂指令集计算机（ CISC ）
    * 各种形式的各种不同指令；但是只有一小部分被 Linux 程序使用；
    * 在性能方面很难和精简指令集计算机（ RISC，一个比较新的指令集 ）竞争；
    * 但是，牙膏厂就是成功了，尤其是速度方面l

## x86 的克隆： 超微半导体（ AMD ）

* 历史： AMD 一直是老二，但是直到最近（ 2019 ）才有所改观。
* 后来：现在逆袭了牙膏厂，并且独立发展了 64 位的指令集；
* 最近：过去十年英特尔处在领先地位，但是现在时代变了。

## 英特尔的 64 位历史

* 2001：英特尔尝试激进的尝试将 IA32 转向 IA64 ；这是个全新的架构（安腾架构），但是性能非常的差劲；
* 2003： AMD 后来居上，并且提出了革命性的 64 位方案；也就是后来的 `amd64` ；
* 英特尔发觉有必要承认 IA64 的失败，并且艰难的承认了 `amd64` 是更好的方案；
* 2004: 英特尔宣布将 IA32 扩展为 EM64T ：和 `x86-64` 几乎一样，是一种内存扩展技术；
* 但是现在所有的 `x86` 处理器都支持 `x86-64` ：但是很多代码还是跑在 32 位之下；

## 我们的范围

* 现在的标准都是 `x86-64` ：

    ```
    shark> gcc hello.c
    shark> gcc -m64 hello.c
    ```

## 若干定义

* 架构（也就是 ISA： 指令集架构）：作为设计处理器的一部分存在，相当于如何编写机器码来使处理器正常工作的标准和规范。

    > **<u>处理器执行计算任务时都需要遵从一定的规范，程序在被执行前都需要先翻译为处理器可以理解的语言</u>** 。这种规范或语言就是指令集（ ISA，Instruction Set Architecture ）。程序被按照某种指令集的规范翻译为处理器可识别的底层代码的过程叫做编译（ Compile ）。 `x86-64`、 `ARM` 、 `MIPS` 都是指令集的代号。

* 微架构：架构的实现方式。

* 代码形式

    * 机器代码：字节形式的，处理器可以执行的程序；
    * 汇编代码：文本形式的机器代码；

## 汇编/机器代码概览

### 对程序员可见的状态

* 程序计数器：存储下一条要执行的指令的地址；在 `x86-64` 环境下被称为 `RIP` ；
* 寄存器文件：程序数据的高频用户；
* 内存：可以在概念上被认为是 **<u>一个可寻址的字节数组</u>** ；存储代码和用户数据；使用栈来管理过程；（虚拟内存：让每个程序在运行起来的时候，感觉像是独占了整个内存，即其他程序的数据对当前程序是不可见的）。
* 条件码：存储最近的算术和逻辑运算的条件码；也为了条件分支做一些存储；

其中「程序计数器」，「寄存器文件」，「条件码」都集成在处理器中；「代码」，「数据」，「栈」都存储在内存中。

> 至于高速缓存（ Cache ），这个部分是对程序员不可见的，因为它只是自动的加载最近实用的数据和代码。但是就程序而言，是不可见的。

## 将 C 代码转换为目标代码

* 在文件 `p1.c, p2.c` 中进行编码；
* 用这个命令进行编译： `gcc -Og p1.c p2.c -o p` ；
    * `-Og` ：表示使用最低优化标准来进行编译；
    * 将编译完成的二进制代码命名为 `p` ；

```
/* Procedure */
C program(p1.c & p2.c)      ---> TEXT FILE
	Compiler(gcc -Og -S)
ASM program(p1.s & p2.s)    ---> TEXT FILE
	Assembler(gcc or as)
Object program(p1.o & p2.o) ---> BINARY FILE
	Linker(gcc or ld)
Excutable program(p)        ---> BINARY FILE
```

## 将 C 程序编译成汇编代码

```C
long plus(long x, long y);

void sumstore(long x, long y, long* dest)
{
    long t = plus(x, y);
    *dest = t;
}
```

```ASM
sumstore:
	pushq %rbx
	movq %rdx, %rbx
	call plus
	movq %rax, (%rbx)
	popq %rbx
	ret
```

调用 `gcc` 的时候，本质上调用的是一系列的程序来完成编译（预处理器，编译器，汇编器和链接器）。

## 汇编语言特性：数据类型

* 「整型」数据有 1, 2, 4, 8 字节的分类：用来存储「数值」和「地址」；
* 「浮点型」数据有 4， 8， 10 字节的分类；
* 代码：使用字节序列来编码一系列指令；
* 没有聚合类数据类型，比如说数组或者结构体，只能在内存中分配连续的区块。

## 汇编语言特性：操作

* 可以使用算术操作来操作寄存器和内存数据；
* 可以在内存和寄存器之间传送数据：
* 跳转控制：条件分支和无条件跳转；

## 目标代码

* 汇编器
    * 将 `.s` 文件转换为 `.o` ；
    * 将每个指令进行二进制的编码；
    * 得到基本上可以运行的可执行代码；
    * 但是没有对不同文件产生的对象文件进行链接；
* 链接器
    * 解决文件之间的引用问题；
    * 将文件和静态链接库进行融合，比方说库函数 `printf` ；
    * 有些库是 **<u>动态链接</u>** 的，也就是说在程序运行的时候进行链接；

## 对目标代码进行逆向汇编

逆向汇编就是使用机器代码产生汇编代码的技术；

### 反汇编器

```
objdump -d sum > sum.d
gedit sum.d
```

* 逆向汇编器对于检查目标代码是一个很实用的工具
* 可以用来分析指令的位模式；

变量的名称在汇编代码中国完全消失，汇编代码不知道在 C 代码中使用了什么样的变量；

还可以使用 `gdb` 来对源代码进行调试，并且可以反向汇编；

```
(gdb) disassemble sumstore
```

## `x86-64` 整数寄存器



## 移动数据

* 移动数据： `movq Source Destine` ;
* 操作数种类：
    * 立即数： 常量整型数据： `$0x400, $-533` ；这些数据和 C 语言中的常数一样，但是前面要加上 `$` 符号；并且基本上使用 1， 2， 4 个字节进行编码。
    * 寄存器：整数寄存器有 16 个： `%rax, %r13` ；但是 `%rsp` 寄存器是为了特殊的目的而准备的；其余的针对特殊的指令有指定的用途；
    * 内存地址：64 位的，由寄存器给出的内存地址： `(%rax)` ； 有若干种地址模式；

## `movq` 能操作的范围

* 「立即数」可以被复制到「内存」或者「寄存器」；
* 「寄存器」中的内容可以被复制到「内存」或者「寄存器」；
* 「内存」中数据只能被复制到「寄存器」中， **<u>不能直接复制到「内存」中</u>** ！

## 简单内存寻址模式

* 常规模式 `(R)` ： `movq (%rcx), %rax` ；这种方式定位的内存就是寄存器中的地址指向的字节 `Memory[%rcx]` ；
* 偏置模式 `D(R)` ： `movq 8(%rbp), %rdx` ；这种方式定位的内存就是寄存器中的地址加上一个偏置值所指向的字节: `Memory[8 + %rbp]` ；

## 理解 `Swap()` 是如何工作的

```C
void Swap(long* xp, long* yp)
{
    long t0 = *xp;
    long t1 = *yp;
    *xp = t1;
    *yp = t0;
}
```

```
xp and yp are two memory addresses;
xp is in %rdi, then yp is in %rsi;
the local variables, t0 and t1 are in the %rax and %rdx
```

```ASM
swap:
	movq (%rdi), %rax ; *xp ---> t0
	movq (%rsi), %rdx ; *yp ---> t1
	movq %rdx, (%rdi) ; t1 ---> *xp
	movq %rax, (%rsi) ; t0 ---> *yp
```

## 复杂内存寻址模式

* 最常用的复杂寻址方式 `D(Rb, Ri, S)` ：
    * `D` ：一个1， 2 或者 4 个字节的偏置常量；
    * `Rb` ：基础地址寄存器：任何一个整数寄存器；
    * `Ri` ：索引寄存器：除了 `%rsp` 的任何寄存器；
    * `S` :尺度： 1， 2， 4 或者 8 ；这个尺度是针对不同数据类型的。

寻址结果为： `Memory[Rb + S * Ri + D]` 。这种寻址方式对于数组的实现是非常有意义的。

* 特殊的复杂寻址方式：
    * `(Rb, Ri)` ： `Memory[Rb + Ri]` ;
    * `D(Rb, Ri)` ： `Memory[Rb + Ri + D]` ;
    * `(Rb, Ri, S)` ： `Memory[Rb + S * Ri]` ;

## 地址计算指令

`leaq Src, Dst` ： 其中 `Src` 是一个地址的表达模式，这条指令将 `Dst` 设置成 `Src` 计算出的内存地址。

### 指令的用途

* 在不用引用内存的情况下计算出地址： `&x[i]` ；
* **<u>计算形如 `x + k * y` 的表达式，其中 `k = 1, 2, 4, 8`</u>** ;

## 若干算术操作符

详情见书本。

## 算术表达式案例

```C
/*************************
 * Argument x => %rdi
 * Argument y => %rsi
 * Argument z => %rdx
 * t1, t2 rval => %rax
 * t4 => %rdx
 * t5 => %rcx
 *************************/

long arith(long x, long y, long z)
{
    long t1 = x + y;     /* leaq (%rdi, %rsi), %rax */
    long t2 = z + t1;    /* addq %rdx, %rax */
    long t3 = x + 4;     /* This step has been optimized */
    long t4 = y * 48;    /* salq $4, %rsi */
    long t5 = t3 + t4;   /* leaq 4(%rdi, %rdx), %rcx */
    long rval = t2 * t5; /* imulq %rcx, %rax */
    /* ret */
}
```

## 机器级编程甲： 总结

* 英特尔处理器以及架构的历史；
* C 语言，汇编语言，机器码
    * 新的可操作部件：程序计数器，寄存器，内存……
    * 编译器必须对声明，表达式，过程作出一系列转换从而将其编程指令序列；
* 汇编基础：寄存器，操作数以及「移动指令」
* 算术
    * C 编译器会自己组合若干种指令来计算相关的内容。

