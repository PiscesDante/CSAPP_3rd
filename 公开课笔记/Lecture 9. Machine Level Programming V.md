# Lecture 9. Machine Level Programming V: Advance Topics

## 今日话题

* 内存布局：当运行 `x86-64` 的程序时，内存是如何组织的；
* 缓冲区溢出（安全漏洞， Attack Lab 的主题就是利用这种漏洞的实验）
    * 脆弱性；
    * 如何避免缓存溢出的发生；
* 联合：一种数据结构；

## `x86-64` Linux 内存布局

* 栈
    * 运行时栈（ 8 MB 的限制 ）：这意味着，如果使用栈指针去访问一个超过 8 MB 范围的地址，将会产生一个段错误（ Segmentation Fault ）；
    * 栈的作用比如说存储局部变量；
* 堆
    * 堆内存在需要的时候进行分配，堆是从低地址向高地址增长的，这个是符合逻辑的，不像栈内存是以高地址为栈底，向低地址增长；
    * 在 C 语言中比方说使用 `malloc()` ， `calloc()` ， `new()` 等函数的时候就会使用堆内存；
* 数据：静态分配的数据，比如说全局变量，静态变量以及字符串等等；
* 文本段 / 共享库（ `printf` ）
    * 「文本段」是存放可执行程序的指令的地方；
    * 这个区域是只读的；

如今的硬件限制我们只能使用 `47` 位（ `0x0007FFFFFFFFFFF` ，这个最大地址也是计算机栈内存区块的起始地址，因为栈是向着低地址增长的 ）的地址。但是随着技术的进步处理器会支持更大的地址范围。

## 一个很大的问题（缓冲区溢出）

* 这个大问题被称作「缓冲区溢出」：这个情况会在数组访问越界的时候发生，那么在编写程序的时候最该考虑的问题就是，我是否应当相信这个索引值；
* 为什么是个大问题：这个问题是造成安全脆弱的首要技术问题；而首要问题则是社会工程学以及用户的主观忽视；
* 缓冲区溢出的常见场景：
    * 未检查长度的字符串输入；
    * 特别是针对字符串，很容易发生缓冲区溢出的问题；

## 字符串库的代码

```C
/* Get stirng from stdin */
char* gets(char* dest)
{
    int c = getchar();
    char* p = dest;
    while (c != EOF && c != '\n') {
        *p++ = c;
        c = getchar();
    }
    *p = '\0';
    return dest;
}
```

这个函数有个显著的问题，如果 `stdin` 输入的字符串明显要比 `dest` 所指向的空间大，那么一定会发生缓冲区溢出，因为读取循环停下的条件仅仅是不为 `EOF` 且不为 `\n` ；所以完全有可能发生溢出；

并且更大的问题是，我们不知道这个 `dest` 是否是一个有效的指针，而这将引发更大的问题。

并且，有问题的代码不止这一个库函数。而这些都是真实的安全问题。

## 易损的缓冲区代码

```C
/* Echo Line */
void echo()
{ /* Type something in and print it back out */
    char buf[4]; /* Way too small */
    gets(buf);
    puts(buf);
}

void call_echo()
{
    echo();
}
```

当调用 `echo` 函数时，在汇编代码中，编译器会给 `buf` 数组设置一个 `24` 个字节的缓冲区，即使这个数组只有 `4` 个字节的长度。故即使输入 `23` 个字符（ `\0` 占一个字节 ），这个函数还是能正常工作。

但是如果输入 `24` 个字符的时候，这个函数就已经不能正常工作，并且会发生缓冲区溢出。

## 代码注入攻击

* 输入的字符串所代表的字节可以被解读成为可以执行的代码；
* 这个字符串会覆盖缓冲区中的返回地址；
* 当正常的函数以被覆盖的地址返回的时候，就会跳转实现准备好的到恶意代码；

这也是 Attack Lab 实验的基本原理。

> ---
>
> 问：当你尝试去替换代码时，如何确定你注入的代码提供了准确的跳转地址？
>
> ---
>
> 答：这就是黑客的天才之处了，这个地址的准确性是由黑客来设计并且提供的。但其实这是一个比较简单地部分，因为你必须在入侵之前就需要掌握代码是如何进行编译的。比如说上面的实验中，我们知道编译器就会给字符串的缓冲区分配 24 个字节。因此，我只要保证我的代码加上填充区是 24 个字节。但是需要知道的细节还是很多，比如说黑客必须事先知道这台机器的操作系统，以及使用什么样的编译器等等。
>
> ---

## 基于缓冲区溢出的一些用途

* **<u>「缓冲区溢出漏洞」可以允许远程计算机针对目标计算机执行一些特定的代码</u>** ；
* 令人沮丧的是这种问题在程序中很常见；
* 几十年之内都有著名的案例（ 1988 年：莫里斯蠕虫 ）；

## 另：蠕虫和病毒

* 蠕虫：是一种可以自行进行运行，并且能给其他计算机完整复制一份自己的程序；
* 病毒：是一段将自己注入到其他程序中，攻击并且改变当前程序的行为，并且无法独立运行的代码；

它们都是被设计用来制造破坏的；

## 如何避免缓冲区溢出攻击

* 在编程时设置阻止缓冲区溢出的条件（削弱缓冲区溢出的易损性）；
* 加强系统级的保护；
* 使用具有「金丝雀」特性的的编译器来编译程序；

## 1. 避免写出缓冲区易损的代码

```C
/* Echo Line */
void echo()
{
    char buf[4]; /* Way Too small */
    fgets(buf, 4, stdin); /* Use fgets instead of gets */
    puts(buf);
}
```

比如说使用更加安全的库函数的撰写代码；

## 2. 加强系统级别的保护措施

* 手段： **<u>栈随机化</u>** （ Address Space Layout Randomization：地址空间布局随机化 ）：
    * 在程序开始的部分分配一段空间作为栈；
    * 为整个程序做出栈地址转换；
    * 让黑客无法准确知道栈的位置在什么地方；
    * 并且让程序在每一次开始执行时，都对栈地址的重新进行分配；

也就是说，让黑客无法知道栈到底在什么位置，就能避免黑客将恶意代码的地址写入栈，从而避免注入而产生的跳转。

* 手段： **<u>不可被执行的代码区域</u>** ：
    * 在传统的 `x86` 系统中，可以将内存区域标记为「只读」或者「可写」，这就导致了任何可读的代码都是可以被执行的；
    * 在 `x86-64` 系统中，添加了一项显式的「可执行」许可，被这个标签标记的内存区块都是可执行的；
    * 栈被标记「不可执行」；

## 3. 栈的「金丝雀」特性

* 想法：
    * 在刚超出缓存区部分的字节放置一个名为「金丝雀」的值；
    * 在执行程序之前检查这个「金丝雀」是否正确；这个金丝雀在每次程序开始执行的时候都会产生一个新的值；
* GCC 的实现；

> 这种灵活的机制会被称为「金丝雀」，这个术语来源于以前的矿井工人。它们每次下井都会带上一只金丝雀，因为这个鸟对毒性非常敏感，当遇到甲烷等毒气之后，就会停止鸣叫或者死亡。

## 面向返回编程攻击

* 对于黑客的挑战：
    * 栈的随机化让预测栈顶的地址变得非常困难；
    * 将栈中的内容标记为不可执行让插入可执行代码变成不可能；
* 替代的策略：
    * 利用现成的代码，将自己的代码注入程序；
    * 将若干段小代码组合起来也许能得到想要的结果；
    * 但是以上的做法无法绕过「栈金丝雀」，这是一种非常强大的技术；
* 从 `gadgets` 击破程序：
    * `gadgets` 是代表部分可执行程序的字节序列，最后一个字节是 `C3` ，这里指的是 `x86` 。这个是 `ret` 指令的编码。

## 联合的内存分配

* 联合的内存分配取决于最大的元素；
* 联合这个结构每次只能使用其中的一个字段；

也就是说，联合体会使用占用空间最大的字段的大小来分配内存，它将假设，你只会同时使用一个字段。如果你存储一个字段，那么它就会覆盖其余的所有字段（至少也会让其他的字段不可用）。

**<u>联合体是一种切换类型并得到不同的位表示形式的技术</u>** 。

```C
#include <stdio.h>

typedef union {
    unsigned char arr_char[8];
    unsigned short arr_short[4];
    unsigned int arr_int[2];
    unsigned long arr_long[1];
} Union;

int main(int argc, char* argv[])
{
    Union rhs;
    unsigned char ch = 0xf0;
    for (size_t i = 0; i < 8; ++i) {
        rhs.arr_char[i] = ch++;
    }
    for (size_t i = 0; i < 8; ++i) {
        printf("| %x |", rhs.arr_char[i]);
    } printf("\n");
    for (size_t i = 0; i < 4; ++i) {
        printf("| %x |", rhs.arr_short[i]);
    } printf("\n");
    for (size_t i = 0; i < 2; ++i) {
        printf("| %x |", rhs.arr_int[i]);
    } printf("\n");
    for (size_t i = 0; i < 1; ++i) {
        printf("| %x |", rhs.arr_long[i]);
    } printf("\n");
    return 0;
}

// OUTPUTS:
// | f0 || f1 || f2 || f3 || f4 || f5 || f6 || f7 | -> arr_char
// | f1f0 || f3f2 || f5f4 || f7f6 | -> arr_short
// | f3f2f1f0 || f7f6f5f4 | -> arr_int
// | f3f2f1f0 | -> arr_long
```

## C 语言中的聚合类型的总结

* 数组：
    * 数组在内存中的分布在物理上是连续的；
    * 在分配过程中可能会进行对齐来满足元素类型本身的对齐需要；
    * 数组名可以作为指向数组第一个元素的指针来使用；
    * 没有边界检查，意味着数组的操作可能越界；
* 结构体：
    * 字段的内存分配顺序是由声明顺序决定的；
    * 可能会在字段之中填充空白字节以满足对齐的需要；
* 联合体：
    * 字段的空间会互相覆盖；
    * 一种规避类型系统的手段；