# Lecture 13. Linking

程序如何与硬件交互，以及它们如何与特定系统软件中的软件交互开始，研究一个叫链接的过程。

## 今日话题

*   链接；
*   案例学习：「 **<u>库打桩</u>** 」技术（这个技术允许你使用链接实际拦截像 C 标准库这样的库中的函数调用）。

## C 语言样例程序

```C
/* main.c */
int sum(int* a, int n);

int array[2] = { 1, 2 };

int main(int argc, char* argv[])
{
    int val = sum(array, 2); /* local */
    return val;
}
```

```C
/* sum.c */
int sum(int* a, int n)
{
    int i, s = 0;
    for (i = 0; i < n; ++i) {
        s += a[i];
    }
    return s;
}
```

## 为什么使用链接？

### 原因 #1 ：模块化

*   模块化允许你将代码分解成更小的部分，可以将相关的功能放入单独的源文件中而不是将所有的代码写在一个巨大的文件中导致根本无法维护。
*   可以撰写属于自己的库函数。

### 原因 #2 ：效率

*   时间：分离式编译
    *   允许修改一个源文件然后重新编译和链接；
    *   不需要编译其他没有修改的文件，这样就会节省很多时间；
*   空间：库
    *   通用的函数可以被集成在一个或者多个写好的文件中重复调用；

## 链接器的工作

链接器的工作有两个： **<u>简单符号解析</u>** 和 **<u>重定位</u>** 。

*   **<u>第一步：简单符号解析</u>**

    *   程序会定义和引用符号（全局变量或者函数等等都被称为符号）：

        ```
        void swap() { ... } /* 定义符号 swap */
        swap();             /* 使用（引用）符号 swap */
        int* xp = &x;       /* 定义符号 xp 并且引用符号 x */
        ```

    *   汇编器将程序定义的符号存储在目标文件中的「符号表」中；这个符号表是一个 `struct` 的数组；每一个结构中都存储着符号的名称，符号的尺寸和符号的地址；

    *   **<u>我们现在所说的符号解析的意思是在链接器链接过程中，链接器将每个符号引用与一个符号定义相关联</u>** ；

*   **<u>第二步：重定位</u>**

    *   将分散的代码和数据区域整合成一个单独的模块；
    *   将对象文件也就是 `.o` 文件中拥有相对地址的符号进行重定位，以获取它们的最终绝对地址，并将绝对地址使用在可执行文件中。
    *   将所有引用相对地址的符号更新到绝对地址。

重定向之前，每个对象文件中的函数地址是基于当前文件的一个相对地址，只有通过链接器进行处理（重定向）之后，才会变成整个程序所看到的绝对地址。

## 三种对象文件（模块）

*   可重定向文件（ `.o` 文件 ）
    *   这个文件包含可以被合并到其他可重定向文件中的代码和数据；
    *   每个 `file.o` 都是产生自一个特定的 `file.c` 的；
*   可执行文件（ `a.out` 文件 ）
    *   包含可以被直接复制到内存中并且进行执行的代码和数据；
*   可共享对象文件（ `.so` 文件，Windows 系统中的 `.dll` ）
    *   一种特殊的重定向文件，该类文件可以被加载到内存中并且通过程序动态的进行链接执行的文件；这是一种创建共享库的现代技术。
    *   这种文件在 Windows 操作系统中被称为 DLL 文件，也就是动态链接库。

## 可执行和可链接的格式（ ELF ）

*   现在目标模块采用称为 EFL 格式的标准格式；
*   这个 EFL 格式是可执行文件，可共享对象文件和可重定向文件的统一格式；
*   具有这种格式的文件有个统一的名称：ELF 二进制；

## ELF 对象文件的格式

*   ELF 头：定义了（生成该文件的系统）的字节顺序和字长；
*   节头部表（只存在于可执行文件中）：指出代码的所有段在内存中的位置（栈的位置，共享库的位置等等）；
*   代码本身：程序代码，出于某种历史原因被称为 `.text` ；
*   只读数据：比方说跳转表等等不能修改的部分；

以上两个部分，代码本身和只读数据部分都是只读的，不会对这两个部分做任何的修改。

*   数据部分：包含了所有初始化全局变量的空间；
*   `.bss` 部分：定义了未初始化的全局变量，这个部分实际上并没有占用任何的实际空间，因为都是一些未初始化的占位符；但是程序加载时就会需要这些变量，在这个时候就会分配给它们内存。
*   符号表部分：包含程序全局变量的结构数组，静态成员等等……；
*   **<u>两个重定位信息部分</u>** ，称为「记录」：当链接器识别所有对符号的引用时，它就会记下一些记录来安排对这个符号的引用；
*   `.debug` 部分：保存源代码行号与机器代码行号的一些关联信息；
*   节头表部分：记录以上所有部分的起始位置（通过偏移量来计算出地址）；

## 链接器符号

对于链接器来说有三种符号：全局符号，外部符号和本地符号；

*   全局符号：在模块 M 中定义，并且可以被其他模块使用的符号；
*   外部符号：被模块 M 使用，但是这个符号是定义在其他模块中的；
*   本地符号：定义和引用都在模块 M 中。

## 本地符号

### 本地非静态 C 变量 VS 本地静态 C 变量

*   本地非静态 C 变量：存储在栈上；
*   本地静态 C 变量：存储在 `.bss` 或者 `.data` 上；

```C
int f()
{
    static int x = 0; /* .data */
    return x;
}

int g()
{
    static int x = 1;
    return x;
}
```

以上程序中，两个函数中都有局部变量 `x` 。常规来说，本地变量只能在对应的作用域中使用，但是 `x` 被声明为静态的，所以这两个 `x` 都存储在 `.data` 部分中。编译器将为这两个 `x` 在 `.data` 上分配空间，并且给它们俩取一个能区别彼此的名字。

链接器将每个引用连接起来，每个符号引用和一个唯一的符号定义相关联；

## 链接器如何处理重复的符号定义

程序的符号被区分为「强」或者「弱」：

*   强符号：过程符号或者已经被初始化的全局符号；
*   弱符号：未被初始化的全局符号；

```C
/* p1.c */
int foo = 5; /* Strong */

void p1()    /* Strong */
{
    ...
}

/* p2.c */
int foo;  /* Weak */

void p2() /* Strong */
{
    ...
}
```

## 链接器的符号准则

*   规则 1 ： **<u>多重强符号是非法的</u>** ——每一个强符号只能定义一次，否则报错；也就是说，如果我们在多个模块中声明一个具有相同签名的函数就是非法的，重载都救不了的那种非法。
*   规则 2 ：如果链接器面临一个强符号和多个弱符号，则总会选择强符号；并且会将本来是引用弱符号的引用解析到强引用上；
*   规则 3 ：如果面临多个弱符号，则随便挑选一个即可（这个情况可能会出现问题）；

通常来说链接器的错误是最糟糕的，因为人们一般不知道链接器到底出了什么问题；

## 全局变量

*   尽量避免使用全局变量；
*   否则：
    *   使用静态全局变量；
    *   在声明全局变量的时候一定要初始化；
    *   在引用外部的全局变量时，使用 `extern` 关键字；

## 第二步：重定位

目前为止，链接器已经将每个符号引用与一些简单地定义相关联。现在它必须获取所有这些对象可重定位目标文件并将它们组合在一起，最终创建一个完整的可执行文件。

## 将常用函数打包

链接的一个真正优势是允许我们创建库。

*   如何将常用的函数打包之后供后来的程序员使用（数学，输入输出或者字符串和内存管理）？
*   现在有两个方法将函数引用进编写的源文件：
    *   选择 1 ：将所有的函数编写到一个巨大的单个文件中，