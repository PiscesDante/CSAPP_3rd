# Lecture 14. Exceptional Control I

## 控制流

*   处理器只会做一件事：
    *   从开机到关机，一个处理器读取并且执行（翻译）一系列的指令，一次执行一条。
    *   这个执行指令的顺序就是处理器的「控制流」。

## 控制流的切换

目前为止我们已经学习了两种控制流的切换机制。

*   跳转和分支；
*   调用和返回；

反映到程序中就是程序状态的改变。

但是操作系统需要能够处理系统级别的变化，也就是说，以上的方法对于一个真正有用的操作系统来说还是不够的，因为改变系统状态是一件非常困难的事情。

*   数据从磁盘到达内存或者网络适配器；
*   除数为 0 的指令（非法指令）；
*   用户按下键盘上的按键；
*   系统时钟所引发的中断

以上都是系统级别的状态变化，操作系统需要一套机制来处理「异常控制流」，因为这些都超出了我们在程序中看到的正常控制进程（条件分支和循环之类的都是正常控制）。

## 异常控制流

*   系统中的所有级别都存在「异常控制流」（ECF）。
*   底层机制
    *   异常：使用控制流变更来响应系统事件（变更系统状态）。这个部分是结合了硬件和操作系统软件来进行实现的。
*   更高级的机制
    *   上下文的切换：使用操作系统软件和硬件时钟来实现；
    *   信号：使用操作系统来实现；
    *   非本地跳转（ `setjmp()` 和 `longjmp()` ）：使用 C 运行时库来实现；

## 异常

异常是一种将一些事件的相应权限移交给操作系统内核的技术。实际上是将低级别的控制权转移到操作系统。

*   操作系统内核是操作系统常驻内存的一部分；

**<u>异常实际上是将低级别的控制权转移到操作系统</u>** 。也就是说，用户代码中一旦出现任何已经由操作系统知晓的情况但是用户代码自己没法解决的时候，就会将控制权转移到操作系统内核中，由内核进行处理。

当内核处理完这个突发情况之后，会有三种结果：

1.  返回到引发异常的指令重新执行；
2.  返回到引发异常的指令的下一条指令继续执行；
3.  终止程序的执行；

## 异常表

*   每一种类型的异常都有一个特定的异常序号 k ;
*   这个 k 代表异常表中的一个索引；
*   每当异常 k 发生时，就会执行异常表中的 k 号异常处理程序；

## 异步异常（中断）

现在有一种异常的分类方法，我们依次将他们区分为「异步」或者「同步」。

*   异步异常是由于处理器的外部事件引起的；
    *   通过在处理器上设置引脚（中断引脚），向处理器通知这些状态变化；比方说磁盘在读写完成之后设置中断引脚来通知处理器文件的访问已经完成；
    *   异常处理程序将返回到异常指令的下一条继续执行；
*   中断的案例：时钟中断
    *   每过几个毫秒，外部的中断时钟就会引发一个中断；
    *   内核就是通过这个机制将控制权夺回的，否则一旦用户程序卡死就整个系统就罢工了；

## 同步异常

同步异常是由执行了某一种指令引起的。

**<u>有一种同步异常被称为「陷阱」，陷阱就是故意的异常。陷阱是一种由用户程序故意引起的异常。最常见的陷阱形式就是系统调用</u>** 。

操作系统的内核为程序提供各种服务，但是程序无法直接使用这些服务，程序无法在内核中调用函数，无法直接访问数据。

操作系统内核的作用是提供一个响应程序发出请求的接口，调用内核中的函数并且发出对各种服务的请求。这就是所谓的「系统调用」。系统调用看起来像一种函数调用，但是却将控制权转移到了系统内核中。

还有一种同步异常被称为「故障」：

*   故障是无意的，但可能是可以恢复的。
*   可恢复的故障包括「页缺失」，「浮点数异常」等等……
*   故障这种异常的结果有两种：要么回到引发异常的指令重新执行，要么直接终止程序；

最后一种同步异常就称为「终止」：

*   无意的，并且是不可恢复的；
*   比方说非法指令等等……
*   将引起终止异常的程序彻底停止；

## 系统调用

*   每一个`x86-64` 系统调用都有一个特殊的 ID 。

```
0 ===> read  ===> Read files
1 ===> write ===> Write files
...
```

## 进程

*   进程的定义： **<u>一个「进程」是一个程序的正在运行的实例</u>** 。
*   进程提供了两个非常关键的抽象：
    *   逻辑控制的抽象：程序似乎在独占处理器进行运行；多个进程需要通过操作系统内核的「上下文切换」这个机制来并发运行。
    *   内存空间的抽象：每个程序似乎独占的使用整个内存空间，多个程序之间是看不到彼此的存在的；这就是操作系统内核提供的「虚拟」内存机制。

对于一个单核处理器来说，所有的进程都在使用一个处理器，而操作系统的工作就是给进程分配处理器的并发使用。

在上下文切换的时候，操作系统就会将当前进程的所有信息保存起来，然后加载即将要运行的进程的所有需要使用的信息，这些被保存和加载的信息就是所谓的「上下文」。上下文的切换就是地址空间和寄存器的变化。

而在现在的多核处理器上，操作系统将在这些多核上分配进程的执行。当然，如果进程的数量超过内核数量，将使用上下文切换来实现并发运行。

## 并发的进程

*   每一个进程都有一个逻辑控制流；
*   如果两个进程的运行在时间上有重叠的部分，我们就称这两个进程是「并发」的；
*   否则，我们就说进程是「连续」的。

## 上下文切换

*   进程由操作系统内核进行管理的，而系统内核是一个常驻在内存中的代码块。
    *   重要的是要意识到，内核不像是一个正在运行的独立进程，它始终在某些现有进程的上下文中运行。
*   控制流利用上下文切换这个机制，从一个进程传递到另一个进程。

## 系统调用错误处理

*   现在的 Linux 系统在遇到错误的情况下通常会返回 `-1` 。并且将设置一个名为 `errno` 的全局变量来指示原因。
*   调用系统级函数的时候有个重要的规则：必须检查每一个系统级函数的返回值；除非系统级函数不会返回任何值。

```C
if ((pid = fork()) < 0) { /* fork 返回子进程的标号，这个标号总是正的 */
	fprintf(stderr, "FORK ERROR: %s\n", strerror(errno));
	exit(0);
}
```

## 包装系统函数

我们可以将系统函数做一个包装：

```C
pid_t Fork(void) {
    pid_t pid;
    if ((pid = fork()) < 0) {
        unix_error("Fork Error.");
    } else {
        return pid;
    }
}

/* 于是我们就可以如下使用 fork 函数*/

pid = Fork();
```

## 创建和终止进程

从一个程序员的视角来说，进程分为三种状态：

*   正在运行：进程正在运行，或者等待运行并且最终被操作系统内核安排运行；
*   停止运行：进程的执行被暂缓，直到有信号让其重新恢复运行；
*   终止运行：进程被彻底终止，并且不再运行；

## 终止进程

*   进程可以因为以下三种原因而被彻底终止运行：
    *   接收了一个终止运行的信号；
    *   从 `main` 函数返回；
    *   显式调用了 `exit` 函数；
*   `void exit(int status)` 
    *   使用状态符 `status` 来终止当前进程；
    *   惯例：如果是正常推出则使用 `0` ，非正常或者错误退出使用非零 ；
    *   要么从 `main` 函数中返回的值也可以被视为 `status` 。
*   `exit` 函数只能被调用一次并且无法返回（这是肯定的，因为进程都让杀掉了）；

## 创建进程

*   父进程可以使用 `fork` 函数来创建一个新的子进程；
*   `int fork(void)` 
    *   在子进程中返回 0 ，在父进程中返回子进程的 `PID` ；
    *   子进程和父进程「几乎」一模一样：
        *   子进程获得父进程虚拟地址空间的相同副本，也就是说子进程和父进程的上下文虽然是独立的，但是内容是一样的，地址空间是相同的。
        *   子进程和父进程会拷贝打开的文件描述符，导致子进程和父进程都会访问相同的文件；
        *   子进程和父进程的进程标号是不同的。
*   `fork` 函数是非常有趣的，因为当调用这个函数之后，它会返回两次。

## `fork` 的案例

```C
int main(int argc, char* argv[])
{
    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0) {
        /* Child Part */
        printf("Child Process: %d\n", pid);
        printf("Child's x = %d\n", ++x); // 2
        exit(0);
    } else {
        /* Parent Part */
        printf("Parent Process: %d\n", pid);
        printf("Parent's x = %d\n", --x); // 0
        exit(0);
    }
}
```

*   `fork` 函数的核心特征就是调用一次，然后返回两次； **<u>在子进程中 `fork` 的返回值是 0 ，但是在父进程中返回值是子进程的标识码</u>** 。
*   **<u>父进程和子进程是并发运行的，所以不能草率的判断谁先执行到什么地方</u>** ；
*   子进程的地址空间是父进程复制的，但是又是相互独立的；
*   在复制地址空间的时候有些对象也是复制的，比方说引用同一个打开的文件的句柄；

## 对 `fork` 函数使用进程图进行建模

进程图的本质是拓扑排序；

## 回收子进程

当一个进程因任何原因终止时，系统实际上还是将其作为进程保留（只不过它自己干活），直到它被创建自己的父进程「回收」，这样做的原因是父进程可能需要知道子进程退出时的状态。

*   当一个进程被终结时，它其实还在消耗系统资源；
*   这样的进程被称为僵尸进程；

### 回收

*   父进程对于被终止的子进程的操作（使用 `wait` 或者 `waitpid` 函数）；
*   父进程将得到子进程的退出状态；
*   最后操作系统内核将删除僵尸子进程；

### 如果父进程没有进行回收？

*   如果父进程在没有回收子进程的情况下就终止了，那么这个子进程被称为「孤儿进程」，这个孤儿进程将被进程序号为 1 的 `init` 进程回收；
*   我们只需要在服务器等场景下才需要显式的子进程回收，因为父进程可能会运行很长时间。

## 僵尸进程案例

```C
void fork7()
{
    if (fork() == 0) {
        /* Child */
        printf("Terminating Child, PID: %d\n", getpid());
        exit(0); /* 仅仅是终止，而非被父进程回收 */
    } else {
        printf("Running Parent, PID: %d\n", getpid());
        while (1); /* 无限循环，不执行进程回收的工作 */
    }
}
```

如果这时候杀死父进程，僵尸子进程将被 `init` 进程回收。

## `wait` ：同子进程同步

**<u>父进程可以通过调用 `wait` 函数来回收一个子进程</u>** 。

```C
int wait(int* child_status);
```

*   将当前的进程暂停直到其中一个子进程被回收，这里并没有指定等待哪一个被回收，而是任意一个子进程被回收就行；
*   这个函数的返回值是被回收进程的进程标号；
*   如果 `child_status != NULL` ，则这个参数将被设置为终止子进程的理由和终止符；这些理由被定义在 `wait.h` 。

## `execve` ：加载并且运行程序

```C
int execve(char* filename, char* argv[], char* envp[]);
```

当我们使用 `fork` 函数的时候，我们只是创建一个以父进程为副本的子进程。运行相同的代码和相同的程序，使用相同的变量。 **<u>要在进程中运行不同的程序，我们需要使用一个叫做 `execve` 的函数</u>** 。

**<u>这个函数会在当前进程中加载并且运行其他程序</u>** 。

这个函数将覆盖当前进程中原本的代码，数据以及栈空间；它会完全覆盖虚拟地址空间，也就是说，只要在当前进程中调用了 `execve` 函数，将完全失去原本的程序信息。但是会保存 PID ，打开的文件和信号上下文。

`execve` 是调用一次，但是从不会返回的一个函数。除非遇到执行错误。

## 总结

### 异常

*   需要非标准控制流处理的事件；
*   要么从程序执行的外部触发异常（中断），要么在程序执行的内部触发异常（陷阱（系统调用）和故障（页缺失））；

### 进程

*   在任何给定的事件，系统都有若干个活动的进程；
*   但是在任意给定的事件，只有一个进程可以使用单核处理器的计算资源；
*   每个进程都认为自己独立的享有处理器的使用权，并且有自己的私「进程」空间；

