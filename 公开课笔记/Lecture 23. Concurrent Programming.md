# Lecture 23. Concurrent Programming



## 并发编程是非常困难的

一般来说，只要有多个进程共享一个资源，那么整个程序就会出现各种奇怪的问题。

**<u>并发编程所面临的经典问题</u>** ：

*   竞争： **<u>结果的好坏取决于任意的调度决策</u>** 。举个例子来说：如果两个人同时访问航空订票系统，那么谁会得到飞机上的最后一个座位？这个问题取决于系统的调度问题。
*   死锁： **<u>有多个控制流等待永远不会发生地事情</u>** 。
*   活锁/饥饿/公平：进程的饥饿表示因为其他进程的优先级较高或者操作系统需要安排的进程过多，那么这个饥饿的进程永远不会被操作系统安排使用硬件资源。

## 迭代式服务器

**<u>在不使用并发的情况下是不可能写出一个正确的服务器的</u>** 。

迭代式服务器的核心问题就是，一旦在对一个客户端服务过程中出现不能完成的情况，那么就会阻塞后来的所有客户端访问服务。

### 解决方案：撰写支持并发的服务器

对于每一个客户请求，服务器都有一个独立的并发流去处理，这样我们通过并发的方式，即使在某一个客户端卡住的情况下，剩下的客户端也不会受到影响。

## 实现并发服务器的几种方式

### 基于进程的并发

*   操作系统内核将自动调度若干个逻辑控制流；
*   每个控制流都会有自己的私有空间；

#### 典型实现方式

基于进程的并发是使用 `fork` 创建子进程去处理发送来的请求，而父进程继续等在原地不会走动，继续侦听其他客户端发送来的请求。也就是说，有多少个客户端请求，父进程就会制造多少个子进程来处理请求。

这样父进程永远不会被请求阻塞。和客户端交互的任务交给了子进程。

### 基于事件的并发（事件驱动）

*   程序员需要自己手动调用流程，而不是依赖内核来调度；
*   所有流都共享一个地址空间；
*   使用的技术叫做 I/O 复用技术；

### 基于线程的并发（进程和事件的混合模式）

*   内核就像进程一样会自动调度线程；
*   但是和进程不同的是，线程共享相同的地址空间；
*   混合了进程和事件模式；

 