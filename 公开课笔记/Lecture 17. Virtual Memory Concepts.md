# Lecture 17. Virtual Memory: Concepts



## 使用物理地址的系统

到目前为止，我们将内存理解成为一个连续的物理字节数组。然后使用字节的偏移量来访问数组中的内容（单片机的内存访问方式）。

## 使用虚拟地址的系统

但是现代的计算机和手机，使用的是「虚拟内存」。

**<u>当我们想要虚拟化一个资源时，我们可以通过介入或者干预对该资源的访问过程来实现这个目的</u>** 。在软件层面，比方说对一个函数进程包装的过程就是原始函数的虚拟化过程。这个相同的技术也可以用来虚拟化其他资源。也就是说，一旦我们拦截了访问资源的过程，那么就可以使用任何想使用的方式来处理他。

处理器在执行指令的时候会生成一个「虚拟地址」，然后将这个虚拟地址发送给一个叫做 MMU ，也就是一个「地址转换过程」，将虚拟地址转换成一个物理地址，最后进行访问。

## 地址空间

**<u>地址空间是一个地址的集合</u>** 。是字节的地址的集合。

*   线性地址空间：连续的非负整数的集合：`{ 0, 1, 2, 3, ..., n }` ；

*   虚拟地址空间：拥有 $N=2^n$ 个虚拟地址的集合；这个 $n$ 是二进制地址的长度：

    `{ 0, 1, 2, 3, ..., N - 1 }` ；

*   物理地址空间：物理地址的空间，通常来说，虚拟地址空间会比物理地址空间大的多。

## 为什么要使用虚拟内存（VM）

*   更高效的使用内存；

    将虚拟内存视为存储在磁盘上的数据的 DRAM 缓存，可以使用这个机制，将虚拟地址空间的一部分实际的存储在物理存储器中。

*   简化内存管理；

    地址空间对任何进程来说都是相同的：代码总是加载到固定的地址等等……每个进程都具有相同的，外观相似的虚拟地址空间。

*   对地址空间进行隔离；

## 虚拟内存对缓存的贡献

*   在概念上，虚拟内存是一个存储在磁盘上的，拥有 N 个连续字节的数组。
*   数组中的内容可以被加载到物理内存（DRAM）中作为缓存供系统使用。

和任何缓存一样，数据被以块的形式缓存，其中每一个块就被称为一个「虚拟页」。有些虚拟页中的内容被缓存在物理内存中。然后有一个映射算法，告诉我们哪些「虚拟页」已经被缓存在了物理内存中。也就是说，虚拟内存中的有些虚拟页没有被存储在物理内存中，甚至都没有被分配给磁盘上的数据。因为我们不可能将所有页都存储在物理内存上。

## DRAM 缓存组织形式

**<u>DRAM 只是一个缓存，但是它的组织形式和我们之前所学的缓存有很大的不同，这种差异是由于未命中时巨大的代价所致</u>** 。

所以这个代价就是虚拟缓存的设计动机。

设计虚拟缓存中的块，也就是虚拟页的大小是需要权衡的。也就是说，既要让从磁盘中获取数据块的代价分弹下来足够小，又不要让数据块过多的占用缓存空间。

**<u>虚拟页的尺寸一般是：4 KB ，有时是 4 MB</u>** 。

缓存需要尽可能的有更大的关联性，我们之前看到的是直接映射的缓存受到冲突未命中的影响。 **<u>所以在设计虚拟内存的时候，所有块都是全关联的</u>** 。也就是说， **<u>任意虚拟页可以被缓存到内存中的任意位置</u>** 。这就需要一个非常复杂的映射函数，必须跟踪所有这些缓存页面的位置。这个冲突消解算法非常复杂，本课程不涉及讲解。但是因为这个算法是软件，于是我们可以负担的起很大的算力开销。

虚拟内存一般不会采取直接将数据写回到磁盘，算法总是采用写回的策略，尽可能的将写回磁盘的操作推迟。

## 关键数据结构：页表

「页表（PT）」是以「页表项（PTE）」为元素的一个数组，页表项是一个保存物理页地址和虚拟页映射信息的一个数据结构。

## 页命中

**<u>页命中就是需要调取的字所在的虚拟页已经被缓存在了 DRAM 中</u>** 。

举个例子，现在处理器中有一条指令生成了一个虚拟地址 VA ，将这个 VA 交给 MMU 之后在页表中进程查找，现在假设这个虚拟地址位于页面 2 中的某个位置。然后就通过解析页表项 2 获取了虚拟页位于内存中的物理地址，这样就找到了所需的数据。

## 页丢失

**<u>页丢失是对没有在物理内存中缓存的字的引用</u>** 。

一旦发生「页缺失」，就会触发进程的异常。操作系统内核需要先将这个缺失的页加载到内存中，然后将控制权转移给触发异常进程，使其重新执行引发缺页异常的指令。

## 处理页丢失

*   页丢失会触发一个缺页异常；
*   页丢失处理函数会在物理内存中选择一个空的或者已经存在，但是关联性较差的虚拟页作为覆盖对象；然后从磁盘中获取缺失的虚拟页存储在指定的物理内存中。最后更新页表中的表项。
*   一旦完成以上的工作之后，就可以重新执行导致页丢失的指令，这回就不会出现页丢失的情况了。

## 分配页

有些虚拟内存中的页仅仅是被登记在页表中，除非被访问，否则不会直接缓存进物理内存中。

## 程序的局部性再次发挥作用

*   虚拟内存在效率方面看起来非常糟糕，但是在局部性的加持下，效果相当不错；
*   在任意时间点上，程序总是倾向于访问一组被称为「工作集」的虚拟页（程序的局部性越好，工作集就越小）；
*   如果工作集的大小小于内存的大小，那么这样的程序虽然会有偶尔的页缺失，但是总的来说将运行的不错；
*   如果所有进程工作集的总大小大于了内存的大小，当发生页加载的时候程序的性能将崩塌式下跌；

## 虚拟内存对内存管理的贡献

**<u>核心思想：每个进程拥有属于自己的虚拟地址空间</u>** 。内核通过每个进程提供自己独立的页表来实现这一点。

```
PROCESS 1 PAGE TABLE: { A:1, C:3, E:5 }
PROCESS 2 PAGE TABLE: { A:1, B:2, D:4, E:5 }
PHYSICAL MEMORY:{ a, b, c, d, e, f, g }
```

**<u>虚拟内存极大的简化了内存管理</u>** ：

*   每个虚拟页面可以被映射到任何一个物理页面中；
*   同一个虚拟页面可以在不同的时间里被存储在不同的物理页面中；

**<u>在进程之间分享代码和数据</u>** ：

*   不同进程的不同虚拟页表项可以指向同一个物理页面；也就是说，只需要在物理内存中有一份数据，让所有需要这份数据的进程将页表项指向这个物理内存即可。

## 虚拟地址对内存安全的贡献

使用虚拟内存的第三个动机是： **<u>帮助我们保护内存中的某个部分</u>** ；

*   **<u>可以对页表项进行一定程度上的扩展，比方说加进一些指示位</u>** ；
*   **<u>MMU 在每次访问物理内存的时候都会检查这些位以确定对物理内存的操作权限</u>** ；

```C
#define TABLE_SIZE 1024
#define BOOL int
#define TRUE 1
#define FALSE 0

typedef struct {
    /* CHECK THESE CONDITIONS FIRST */
    BOOL is_supervisable; /* ADMINISTRATOR MODE */
    BOOL is_readable;
    BOOL is_writable;
    
    /* IF THIS CONDITION IS FALSE
     * THEN THE BYTES ON THE PHYSICAL ADDRESS
     * CANNOT BE TREAT AS CODE */
    BOOL is_executable = FALSE;
    
    /* IF is_valid == FALSE : PAGE NOT IN MEMORY */
    BOOL is_valid;
    /* VIRUTAL ADDRESS ---> PHYSICAL ADDRESS */
    unsigned long physical_page_address;
} page_table_element;

page_table_element page_table[TABLE_SIZE];
```

## 虚拟内存的地址翻译

*   如果生成的虚拟地址带入地址转换算法之后能够计算出一个物理地址，那么就说明当前的虚拟地址指向的数据已经被缓存在内存中了；
*   如果生成的虚拟地址带入地址转换函数之后计算出来是空，那么就说明需要调用的数据不在内存中；

## 使用页表进行地址转换

**<u>地址转换的目的，就是为了对于一个给定的虚拟地址，通过一些特定的手段来得到一个特定的物理地址</u>** 。物理地址中的物理页码来自页表项。物理地址的物理页面偏移部分来自虚拟页面偏移。

## 地址转换：页命中

处理器会在执行指令（移动，调用，返回等等……）的时候向 MMU 发送生成的虚拟地址，MMU 从存储在内存中的页表获取对应的页表项。获取了对应的页表项之后会使用这个页表项来构造物理地址。然后将这个计算出来的物理地址发送到缓存和内存系统，最终将数据提交给处理器。

**<u>即使是页命中的情况，我们仍然需要访问内存</u>** 。

## 地址转换：页丢失

页丢失也被称为缺页错误。

大致过程同页命中，只不过在计算出页表项的时候发现该页表项中的有效标志位为 `0` ，这就说明存储这个数据的虚拟页没有被存储在内存中。这就会引发「缺页异常」，该异常会将控制权转移到「缺页异常响应函数」，函数选出一个牺牲页将其用指定的虚拟页进行覆盖（如果牺牲页已经被修改，那么就先将修改写入到磁盘），做完这一系列工作之后将控制权交还给引发缺页异常的指令使其重新执行即可。

## 使用 TLB 来加速地址翻译

**<u>页表项也会像其他内存字一样存储在 L1 缓存中</u>** ：

*   所以页表项可能被其他数据引用所驱逐；
*   即使命中，页表项也需要一个很小的 L1 延迟；

**<u>解决方案：翻译查询缓冲（Translation Lookaside Buffer）</u>** ：

*   TLB 是一个硬件缓存，缓存的内容是页表项；
*   主要的功能就是将虚拟地址映射到物理地址上；
*   缓存了最近使用的页表项；

现在有了 TLB 这个缓存中间件，MMU 收到处理器发送的虚拟地址后，不会直接去内存中访问页表，而是会选择去 TLB 中查找对应的物理地址。如果命中，就会直接将查到的物理地址发送给内存系统，最终将数据返回给处理器。

## 层级化的页表结构

链式查表。

这个部分需要去仔细阅读课本的相关内容。

## 总结

**<u>程序员视角下的虚拟内存</u>** ：

*   每个进程拥有自己的私有线性地址空间；
*   这个地址空间不能被其他进程所访问；

**<u>虚拟内存的系统概念</u>** ：

*   通过缓存虚拟内存页来高效的使用内存，高效的核心原因是程序的局部性；
*   简化了程序设计（链接部分）以及内存管理；
*   通过扩展虚拟内存的管理方式简化了内存的读写保护。

