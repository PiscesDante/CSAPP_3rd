# Lecture 7. Machine Level Programming III: Procedures

## 过程的机制

* 控制的传递
    * 到达指定代码的开始处；
    * 返回返回点；
* 数据的传递
    * 处理实参；
    * 返回数值；
* 内存管理
    * 在程序执行期间分配内存；
    * 在返回前释放掉分配的内存：特别是 C 语言，我们需要确保函数返回的局部数据所分配的空间应当在返回前释放掉；
* 这些机制全部由机器指令进行实现。
* `x86-64` 对于过程的实现仅仅用到了那些需要的机制。

## 今日话题

### 过程

* 栈结构。
* 调用的惯例：
    * 传递控制权；
    * 传递数据；
    * 管理局部数据；
* 关于递归的解释。

## `x86-64` 栈

* 将一部分的内存区域以栈的工作方式来管理；
* 栈底位于「高地址」，然后向「低地址」增长；
* 寄存器 `%rsp` （Register of Stack Pointer）包含栈的最低地址，也就是所谓的「栈顶指针」。 **<u>栈顶指针指向栈顶的元素，并不指向栈顶元素的下一个空位</u>** ；

**<u>对于汇编层面的程序员而言，内存只是一个巨大的字节数组</u>** 。在这个数组中的一部分我们称为「栈」。 **<u>程序使用栈来管理过程的调用和返回的状态</u>** 。在栈中，程序传递潜在信息，控制信息和数据，并且分配本地数据。

## `x86-64` 栈：入栈

* `pushq Src` ：
    * 取出存在 `Src` 中的操作数；
    * 将 `%rsp` 栈顶指针的值减小 `8` ；
    * 将取出的操作数写入栈顶指针指向的内存地址。

## `x86-64` 栈：出栈

* `popq Dest` ：
    * 读取栈顶指针 `%rsp` 所指向的内存区域的内容；
    * 将栈顶指针 `%rsp` 增加 `8` ；
    * 将读取的内容存在 `Dest` 中， **<u>这个 `Dest` 必须是个寄存器</u>** 。

出栈操作中，仅仅移动了栈指针而已，并没有将原本位于栈顶的内容抹掉，只是不是栈的一部分了。

## 过程控制流

* 使用栈来支持过程的调用和返回；
* 过程调用： `call LABEL` ：
    * 将返回点的地址入栈；
    * 跳转到标签处；
* 返回地址：
    * 「返回地址」就是 **<u>调用指令的下一条指令的地址</u>** ，否则会产生无限循环调用；
    * 反汇编的例子；
* 过程返回： `ret` ：
    * 将栈中的返回地址出栈；
    * 跳转到刚刚出栈的地址上；

`call` 和 `ret` 两个指令并没有完成过程调用与返回的全部任务。这两个指令只是完成了控制部分。控制部分只是过程调用的三个方面之一（参数传递，局部变量管理）。

`%rip` 这个寄存器我们永远无法自主操控，操作这个寄存器是 `call` 指令的一部分内容。

## 过程数据流

我们已经看到 `%rax` 用于存储函数的返回值。这些都是特别的规定，并不局限于实现的硬件。特别的，规则要求前六个参数通过以下特定的寄存器来传递：

```
/* First 6 arguments */
%rdi, %rsi, %rdx, %rdi, %r8, %r9

/* Return value */
%rax
```

然后剩下的参数使用「栈」来进行传递。对于上边的寄存器顺序是需要记住的，或者手边放上一个表格以供随时查看。

在以往的 `iA-32` 时期，所有的参数都使用栈来传递。但是现在绝大多数情况下，参数是使用栈来传递的。

## 数据流案例

基本上代码能运行是基于这样的假设： **<u>无论什么参数，都按照列出的顺序，被传递给这一系列寄存器；如果过程具有返回值，那么处理方式就是将返回值存入 `%rax` 寄存器</u>** 。这样调用过程就可以假设寄存器 `%rax` 保存了被调用过程所产生的返回值。

重点在于，如果每个人都按照这样的规则来编写代码或者设计硬件，那么我们就可以使用不同的编译器来编译代码而不出错。

## 基于栈的语言

* 支持递归的语言：
    * 例如： C ， Pascal ， Java ；
    * 代码或者过程必须可以「再进入」：一个「过程」的多个同时的「运行实例」；
    * 需要为每一个过程实例来分配存储的空间：参数，局部变量，返回点；
* 栈规则：
    * 给定的过程状态需要明确的时间限制：何时调用以及何时返回；
    * 被调用者必须在调用者返回之前返回；
* 栈被分配成「帧」的形式存在：一帧代表了一个过程实例。

因此，我们将栈上用于特定 `call` 的每个内存块称为「栈帧」。更加技术性的说法是，它是特定过程调用的特定实例的栈帧。

## 栈帧

* 关于栈帧的内容：
    * 返回信息；
    * 局部存储（如果需要的话）；
    * 临时空间（如果需要的话）；
* 管理：
    * 当进入一个过程时，空间就会被分配；
    * 当过程返回时，分配的内存将被释放；

通常一个栈帧由两个指针进行分隔，首先是「栈指针」 `%rsp` ，指向当前正在执行的过程；然后还有一个「基指针」，由寄存器 `%rbp` 保存，这个指针指向。但是基指针是一个可选指针。并且再汇编代码中是不会使用这个基指针的。所以一般情况下是无法确定栈帧的确切范围的。

同迭代相比，随着递归的深入，这个操作需要不断占用更多的栈空间。并且，绝大多数系统限制了栈的最大深度，从而避免栈溢出的情况发生。

问：既然 `%rbp` 是可选的，那么程序是如何知道该怎样释放空间？答：因为在分配的时候将留下分配的信息（也许包括分配了多少个字节），所以可以知道该如何释放空间。

但是还是有一些特殊情况，它无法提前知道将分配多少空间。例如它必须分配一个可变大小的数组或者内存缓冲区时。这时它实际上会使用 `%rbp` 来实现这个目的。

## `x86-64` 以及 Linux 的栈帧

* 当前栈帧（自上而下的结构）：
    * 「建立参数」：参数或者调用者函数的信息；
    * 局部变量：如果有些变量不能保存在寄存器中；
    * 保存的寄存器内容；
    * 旧的栈帧指针（可选的）；
* 调用者栈帧：
    * 返回点的（内存）地址：这个地址由 `call` 指令推入栈中；
    * 调用所使用的实参；

如果我们将传递 6 个以上的参数给被调用函数，那么调用者实际上将使用自己的栈帧来存储这些参数，最后将返回点地址也压入自己的栈帧中。这样，在被调用过程开始之前，实参以及返回点地址就已经在栈（栈帧）中了。并且，如果我们使用 `%rbp` 这个「基指针」的话，也要将基指针压入栈中，这样就会在返回时恢复。

## 案例： `incr` 

```C
long incr(long* p, long val)
{
    long x = *p;
    long y = x + val;
    *p = y;
    return x;
}
```

```ASM
# p               ---> %rdi
# val, y          ---> %rsi
# x, return value ---> %rax

incr:
	movq (%rdi), %rax # *p ---> x
	addq %rax, %rsi   # x + val ---> y
	movq %rsi, (%rdi) # y ---> *p
	ret # return x
```

## 案例：调用 `incr` #1

```C
long call_incr()
{
    long v1 = 15213;
    long v2 = incr(&v1, 3000);
    return v1 + v2;
}
```

```ASM
call_incr:
	subq $16, %rsp # %rsp -= 16 -> prepare for pushq
	movq $15213, 8(%rsp) # push 15213 to the stack
	movl $3000, %esi # move 3000 the argument to %rsi
	leaq 8(%rsp), %rdi # move the address of 15213 to %rdi
	# now the address of 15213 is in the %rdi
	# argument 3000 is in the %rsi
	# it is ready to call [incr]
	call incr # the return value is stored in %rax
	addq 8(%rsp), %rax # add 15213 to the %rax
	addq $16, %rsp # %rsp add 16(pop)
	ret # return value is in the %rax
```

**`ret` 指令将始终采用栈指针指向的地址，并将其作为返回地址** 。所以将 `%rsp` 在执行 `ret` 指令前就将其恢复到原来的位置是非常重要的。

## 保持寄存器的惯用手法

* 当过程 `yoo` 调用 `who` ：

    * `yoo` 是调用者( Caller )；
    * `who` 是被调用者( Callee )；

* 是否能将寄存器作为临时存储器来使用？

    ```ASM
    yoo:
    	...
    	movq $15213, %rdx # %rdx = 15213
    	call who
    	addq %rdx, %rax
    	...
    	ret
    
    who:
    	...
    	subq $18213, %rdx # %rdx = 15213 - 18213
    	...
    	ret
    ```

    * `yoo` 在调用 `who` 之前写在寄存器 `%rdx` 的内容被 `who` 给覆盖掉了！
    * 这将造成很大的麻烦：必须采取措施防止这样的事情发生，必须进行协作。

* 惯用手法（管理寄存器的两种方法）：

    * **<u>调用者保存</u>** ：调用者在调用发生之前，将临时数值保存在它自己的栈帧中；
    * **<u>被调用者保存</u>** ：被调用者将一些的临时数据保存在自己的栈帧中，然后在返回到调用者之前将保存的数据还原；

## `x86-64` Linux 寄存器的使用方式 #1

* `%rax` ：返回值；调用者保存；可以被「被调用者」修改；
* `%rdi, ..., %r9` ：实际参数；调用者保存；可以被「被调用者」修改；
* `%r10, %r11` ：调用者保存；可以被「被调用者」修改；

从这里看出， Linux 对于寄存器的节约方式在于「调用者」。

我们已经看到 `%rax` 用于返回值； 六个寄存器用来传递参数；两个寄存器用来存放可以被修改的数据。

## `x86-64` Linux 寄存器的使用方式 #2

* `%rbx, %r12, %r13, %r14` ：被调用者管理；被调用者必须将这个数据保存并且恢复；
* `%rbp` ：被调用者管理；被调用者必须将这个数据保存并且恢复；可能会被当成栈基指针使用；
* `%rsp` ：特别需要被调用者管理；在过程退出并且返回之前，必须将其中的原始值恢复；

## 基于递归的一些观察

### 递归的原理都非常的基本，没有什么特殊的

* 栈帧的运用表示每个函数调用都有一个私有空间：用来存储寄存器中的数据，局部变量以及返回点指针；
* 寄存器的保持手段能避免函数在调用之间互相覆盖数据造成数据丢失（除非使用 C 语言明确这样做）；
* 栈的概念同过程调用和返回的模式相匹配；

### 可以实现辗转递归

* P 调用 Q， Q 再调用 P；