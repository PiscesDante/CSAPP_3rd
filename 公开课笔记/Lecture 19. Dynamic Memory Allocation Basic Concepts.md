# Lecture 19. Dynamic Memory Allocation: Basic Concepts



## 动态内存分配

**<u>程序员使用「动态内存分配器」（比如说 `malloc()`）来在运行时请求虚拟内存</u>** 。

*   动态内存是给一些只能在运行时才知道大小的数据结构准备的；

**<u>动态内存分配器管理着一个叫做「堆」的进程虚拟内存区块</u>** 。

## 动态内存分配

**<u>分配器将「堆」作为一个连续的区块集合来维护，并且这个集合的大小是可以进行变动的，也就是说虚拟内存可以被分配，也可以被释放</u>** 。

*   显式分配器：应用程序会分配和释放空间，例如调用 `malloc()` 和 `free()` 函数；
*   隐式分配器：应用程序虽然自己分配，但是不会自己释放空间；比如说 Java 语言的垃圾回收机制；

## `malloc` 工具包

```
#include <stdlib.h>
void* malloc(size_t size);
```

*   分配成功：返回一个通用指针，这个指针指向 `size` 字节的，并且根据系统要求进行对齐（32 位是对齐到 8 个字节，64 位是对齐到 16 个字节）的一个内存区块；如果 `size == 0` 那么返回 `NULL` ；
*   分配失败：返回 `NULL` 并且设置 `errno` ；

```
#include <stdlib.h>
void free(void* pointer);
```

*   这个 `pointer` 指向的地址必须是 `malloc` 或者 `realloc` 函数分配的地址；

## `malloc` 案例

```C
#include <stdio.h>
#include <stdlib.h>

void malloc_example(int size)
{
    /* ALLOCATE A BLOCK OF SIZE INTS */
    int* dynamic_array = (int*)malloc(size * sizeof(int));
    /* 因为 malloc 函数返回的指针是个通用指针，所以将这个通用指针显式
     * 转换为特定类型的指针，然后再进行操作 */
    /* IF ALLOCATION IS FAILED */
    if (dynamic_array == NULL) {
        perror("MALLOC ERROR.");
        exit(0);
    } else { /* ALLOCATION IS SUCCESSFUL */
        for (int i = 0; i < size; ++i) {
            /* INITIALIZE ALLOCATED BLOCK */
            dynamic_array[i] = i;
        }
        /* RETURN ALLOCATED BLOCK OF THE HEAP */
        free(dynamic_array);
    }
}
```

## 约束

对于应用程序来说：

*   可以以任意顺序来调用 `malloc` 和 `free` 函数；
*   `free` 函数中使用的指针，必须指向 `malloc` 分配的内存区块；

对于分配器来说：

*   分配器无法控制分配块的大小和数量（分配器无法控制应用程序做事）；
*   如果有应用程序调用 `malloc` ，它必须立刻进行响应，也就是说分配器无法缓存或者记录请求；
*   必须从空闲的块中分配内存，也就是说，即使一块内存是被泄漏的，也不能覆盖其中的数据； **<u>同时，也不能随意移动已经分配的区块来「凑零为整」的为其他程序腾地方</u>** ；
*   分配的内存必须根据系统要求进行对齐操作；
*   只能操作或者修改空闲的内存区域；

## 性能指标：吞吐量

分配器需要在时间和空间上进行权衡，也就是说它既要很快的响应内存分配的需求，也要考虑内存分配的合理性；编写一个具有很糟糕的内存利用率但是速度很快的分配器非常容易，但是权衡兼顾就会变得非常困难；

**<u>「吞吐量」是每单位时间所有的请求的数量</u>** 。如果我们在 10 秒内调用了 5000 次 `malloc` 和 5000 次 `free` ，那么吞吐量就是 $(5000 + 5000)/10=1000$ 。

吞吐量就是评价 `malloc` 处理来自应用程序的请求效率。

## 性能指标：峰值内存利用率

这个指标衡量分配器使用堆的效率有多大，也就是分配器在分配内存的方式有多少浪费；

*   负载：每次调用 `malloc` 都会产生一个负载；
*   堆大小：也就是堆的尺寸；
*   **<u>在 k + 1 次分配和释放之后，其峰值内存利用率是</u>** ：$U^k=(max_{i\le k}P_i)/H_k$ 。

## 碎片

碎片会导致很低的内存利用率，主要有两种内存碎片：

*   内部碎片：对于给定的块，内部碎片是由有效负载小于区块大小导致的；引起的原因可能有：
    *   给程序过度分配大小；
    *   为了系统内存的对齐要求；等等……
*   外部碎片：就是当分配器要分配一段空间时，总的空闲空间是足够的分配的，但是却没有一块单独的空闲空间可以使用。

## 实现的问题

*   如果我们调用了 `free` ，那么 `free` 如何知道要释放的内存区块的具体大小？
*   我们如何确定哪些堆内存是空闲的？
*   对于没有填满空闲内存区块所剩下的空间，我们应当怎么办？
*   对于一块需要分配的内存，如何选择安放它的空闲区块？

## 确定需要释放的内存大小

标准方法： **<u>在分配内存时多分配一个字的空间，然后将区块的长度信息放在这个字中进行保存</u>** 。这个方法实际需要 k + 1 个字。这个字也被称为「头部域」或者「头」。

## 持续跟踪已经分配的内存区块

*   **<u>隐式空闲块列表法</u>** ：核心思想就是在堆中的每个块前面都放置一个头部，无论是被分配的还是空闲的，然后我们可以在堆的开头使用它，可使用头部记录的大小来访问堆。
*   显式空闲块列表法：在隐式的基础上再多申请一个字来存储下一个空闲块的首地址。
*   分类空闲列表法：对于不同大小的空闲区块，分别记录在各自对应的列表中。

## 隐式空闲块列表法

**<u>对于每个内存块来说，我们需要「尺寸」和「分配情况」两个指标</u>** ，但是将这两个信息存储在两个字中也太浪费了。

### 标准的实现方法

*   如果内存块总是根据 8 或者 16 对齐的，那么这个地址的低位将总是 0 ；比如说如果一个块总是 8 位对齐，那么这个块的地址的低 3 位将总是 0 ，16 位对齐下，低 4 位总是 0 。（任何 8 字节对齐的块的大小必须是 8 ，并且地址必须是 8 的倍数）

*   于是，我们可以利用这个规则，将本来应当总是为 0 的三位或者四位加以利用，来标识这个块的状态是被分配的还是空闲的；

## 隐式列表：找到一个空闲块

**<u>寻找第一个合适的区块（首次适配）</u>** ：

*   从列表的第一个开始寻找，找到第一个空闲的，可以使用的区块：

    ```C
    current = begin;
    while (current < end && /* NOT PASSED END */
          ((*current & 1) || /* ALREADY ALLOCATED */
           (*current <= size))) /* TOO SMALL TO FIT */
        current = current + (*current & -2); /* GOTO NEXT BLOCK */
    ```

*   这个查找过程所用的时间是线性的；

**<u>寻找下一个合适的区块（下次适配）</u>** ：

*   和首次适配一样，下次适配是从最后一次离开的地方开始寻找合适的空闲区块；
*   理论上应当比首次适配要快速，因为不用去重复扫描；
*   但是有些研究也表明，使用这种策略碎片将更加严重；

**<u>最佳适配</u>** ：

*   搜索整个列表，找到那个最合适的空闲区块，也就是那个利用率最高的区块；
*   这个策略可以使碎片问题最小化；
*   但是这个策略也是最慢的；

## 隐式列表：分配内存

分配内存的方式有两种，假设现在的场景是程序需要 4 块内存，但是我们找到了 6 块连续的内存：

*   取整策略：将这 6 块内存全部分配给程序，也就是说多给了程序 2 块内存；
*   找零策略：将这 6 块内存劈开，只给程序 4 块内存，剩下的 2 块标记为空闲区域；

## 隐式列表：释放内存

**<u>最简单的实现</u>** ：

*   将需要释放的区域清零并且标记为空闲即可；
*   但是这个策略的问题在于，会加剧内存空间的碎片化；如果使用「找零」的分配策略，会将原本为 6 块连续空闲区域变成 4 块空闲区域 + 2 块空闲区域；

优秀的内存分配器永远不会让内存出现连续的空闲区域；

## 隐式列表：双向合并

**<u>边界标签（高德纳 1973）</u>** ：在一段内存的首和尾放置其相关信息，即可解决问题；

## 改进

对于已经分配的区块，我们不需要知道其大小，因为不会合并；

## 核心分配器策略总结

**<u>选址策略</u>** ：

*   首次匹配，下次匹配，最佳匹配；
*   通过牺牲吞吐量来减少碎片化；
*   有一些有趣的方法可以提高最佳匹配策略的性能：也许我们不需要搜索所有的内存区域来找到不错的空闲区域；

**<u>分割策略</u>** ：

*   当我们找到一块组够大的内存区域，我们应当如何处理多余的空间？
*   这个取决于对于碎片化的容忍度；

**<u>合并策略</u>** ：

*   立刻合并：在每次 `free` 调用之后都进行合并；
*   推迟合并：在调用若干次 `free` 之后才进行内存整理；

以上策略的选择都是权衡的结果。

