# Lecture 12. Cache Memories

**<u>内存层次结构是存储设备的集合</u>** 。上一级的存储器将作为下一级存储器的高速缓存。

## 内存高速缓存

*   **<u>高速缓存存储器</u>** 是基于 SRAM 的一种小型快速的存储器，这个存储器被硬件自动的进行管理。（存储内存中经常被访问的块）
*   当处理器需要数据的时候，会首先在高速缓存存储器中寻找需要的数据。

内存高速缓存这个设备是集成在处理器内部的。

## 普通的高速缓存组织方式

高速缓存完全由硬件管理，所以这里的关键点是： **<u>硬件逻辑需要知道如何查找缓存中的块，并且确定是否包含特定的块</u>** 。必须以非常严格的方式进行组织。

**<u>每个缓存都有 S 组，每个组都有 E 块，并且每个块都有 B 个字节</u>** 。

## 读取缓存（核心概念）

当程序需要内存中的某个值时，处理器将这个值的地址首先发送到高速缓存。询问并且要求缓存返回这个地址上的数据。

高速缓存的控制器收到这个地址之后，会将地址划分为 3 块：Tag 域，Set Index 域和 Block Offset 域。首先控制器将查看 Set Index 并且核对是否有符合条件的组存在；若有相应的组存在，那么进行下一步。

找到对应的组之后，控制器会访问 Tag ，来检查该组中的所有行是否有任何匹配到当前地址 Tag 的标记；并且查看这个有效位是否为 1 。如果这两个条件成立，那么就称为「命中」。

最后使用 Block Offset 域来确定数据所在位置的偏移量，并最终取得数据。

## 直接映射的缓存模式

总结一下，高速缓存控制器拿到一个地址之后将地址分解为标签，组别和数据偏移量。将过程编写为伪代码即：

```
{ tag, set_index, block_offset } = memory_address;
if (set_index in memory_cache) {
	if (verity_bit == 1) {
		if (tag == cache_tag) {
			HIT;
			return cache_block[block_offset];
		} else {
			MISS; /* 因为 Tag 冲突而未命中 */
		}
	} else {
		MISS; /* 因为 有效位 为 0 而未命中（冷未命中的情况） */
	}
} else {
	MISS; /* 因为没有找到指定组而未命中 */
}
```

高速缓存中替换块的算法之一：根据局部性原则，计算机希望将缓存中的款尽可能的被多次使用。所以逆着局部性原则来思考，我们就需要将最不频繁使用的块替换掉。

原则就是将最常用的块保留下来即可。块的目的就是为了程序的局部性。

## 写的情况（以上是使用缓存进行读取的情况）

*   一份数据可能在 L1， L2， L3， 内存和磁盘中有都存在（复制品）。

*   如果在「写命中」的情况下该如何做？

    *   直接写入（直接向内存中写入数据）。耗费高的写方式；

    *   「写回」：这种情况下我们将数据写入缓存中的块，它不会立即将其再写入到内存中，直到这个块被作为替换者进行覆盖的时候，向内存中写的操作才会发生。

        对于写回方法，需要多余的位来标记是否应当被写回内存中。

*   如果发生了「写丢失」（也就是我们需要写入的数据不在任何高速缓存的块中）的情况该如何做？

    *   「分配式写入」：将数据写入高速缓存的指定块的行（新行），然后再将数据写入内存中。
    *   「非分配式写入」：直接将数据写入内存中，不经过高速缓存中转。

## 高速缓存性能的度量方法

*   **<u>未命中率</u>** ：每查询 100 次数据没有在高速缓存中查到的次数。

    一般来说， **<u>L1 有 3% ~ 10% 的概率未命中，但是对于 L2 这个概率就会下降到 1% 以下</u>** ；

*   **<u>命中时间</u>** ：如果我们在缓存中有一个命中，那么它实际需要多长时间才能找到？

    一般来说 L1 需要 4 个时钟周期，而 L2 则需要 10 个时钟周期；

*   **<u>丢失惩罚</u>** ：当未命中的情况下需要的数据读取时间。

    一般情况下需要 50 ~ 200 个时钟周期从内存中读取数据（而且这个用时有增大的趋势）。

## 面向高速缓存撰写代码

*   让普通的程序跑得更快：针对核心函数和内循环进行优化；
*   尽量减少内循环中的命中丢失问题：
    *   重复的使用临时变量是很好的实践（临时局部性）；
    *   撰写步长为 1 的代码（这里的步长指的是第 k 步和 k + 1 步的所访问的内存地址的间隔，也就是空间局部性）。

**<u>高速缓存的使用使得我们可以对局部性这个特点进行量化，也就是说一个程序的局部性是否符合要求，可以从它对层级化内存系统的方式上看出来</u>** 。

## 存储器山

描绘了一种称为「吞吐量」或者「读带宽」的衡量标准，也就是从内存中读取的字节数。

「存储器山」本质上是一个自变量为步长和数据量，因变量为数据吞吐量（MB/s）的函数图像（因为这个函数图像长的像一座山）。这个函数充分证明了充分利用局部性将收到什么样的性能提升。

## 高速缓存存储器总结

*   高速缓存存储器对于程序性能的影响将至关重要。
*   我们可以撰写面向高速缓存的程序来加以利用；
    *   专注于最内层的循环，因为大多数复杂的计算和逻辑处理都在这个地方；
    *   尝试最大化空间局部性，最好以步长为 1 的方式去存取数据；
    *   尝试最大化临时局部性，最好经常使用同一个临时变量来存取数据；

