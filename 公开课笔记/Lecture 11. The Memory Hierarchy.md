# Lecture 11. The Memory Hierarchy

## 今日话题

*   存储的技术和趋势；
*   程序的局部性（Locality of Reference）；
*   分级内存的缓存策略；

## 随机访问存储器（ RAM ）

### 核心特性

*   RAM 经常被集成为一个单独的元器件（芯片）；
*   最基本的存储单元通常是一个「单元」（每个细胞代表 1 个位）；
*   很多个 RAM 芯片组成了内存；

### RAM 有两种形态

*   SRAM （ 静态 RAM ）；
*   DRAM（ 动态 RAM ）；

## SRAM 和 DRAM 的对比

*   SRAM 需要更多的晶体管来存储数据，因此造价也非常高，并且比 DRAM 的速度要快的多；
*   DRAM 需要插着电用。SRAM 不需要错误检测和纠正。
*   SRAM 用于内存容量小但是需要速度非常快的芯片中，我们称之为高速缓存；DRAM 用于内存等等用途。

## 非易失的存储

*   DRAM 和 SRAM 都是易失性存储：当设备断电之后，存储的东西就丢失了；
*   非易失性存储即使在断电的情况下还是能保存其中的数据；
    *   ROM ：再生产的过程中已经编写好了程序，程序是被硬编码在硬件中的；
    *   PROM ：只能被自定义编写一次，这也就是 Programmable 的来源；
    *   EPROM ：可以被紫外线或者 X 光擦掉（ Erasable ）其中的数据然后重新注入；
    *   EEPROM ：可以使用电子（ Electronic ）来擦除其中的数据然后重新注入；
    *   闪存（ Flash Memery ）：EEPROM 的进化版，可以针对特定区块对数据进行擦除和写入，但是这个擦除次数是有限制的，一般来说对于一个存储单元擦除的限制是 100000 次。
*   非易失性存储的用途
    *   硬件层面的程序一般存储在 ROM 中，比如说计算机的 BIOS ，网卡的 I/O ，子系统等等，这些硬件的程序只需要撰写一次即可。
    *   SSD ，也就是常说的固态硬盘；

## 传统的总线连接结构：处理器和 RAM

*   总线一个集合，这个集合中包含一系列并行的电线，用来传递地址，数据以及控制信号。
*   总线一般来说被好几个设备共享。

主存，也就是我们所说的内存，是通过一些电子线路连接到 CPU 的。这些电子线路就被统称为总线。任何数据和信号都是通过总线在各个元器件之间传输。

## 内存读取传输 #1 #2 #3

内存中的数据是如何通过总线传输到各个元器件的。

## 磁盘驱动器中有什么？



## 磁盘的几何构成

*   磁盘由盘片构成，每个盘片中有 2 个盘面。
*   每个盘面由叫做「磁道」的同心圆组成；
*   每个磁道又被「间隔」划分为「扇区」；

## 磁盘容量

*   容量：磁盘所能存储的比特数；
*   容量受以下技术因素影响：
    *   记录密度：1 英寸的磁道上所能承载的比特数量；
    *   磁道密度：1 英寸半径上所能容纳的磁道数量；
    *   盘面密度：磁道密度 ×记录密度；

## 记录区

*   现代磁盘将磁道划分为彼此独立的子集，这个子集就被称为「记录区」
    *   记录区中的每个磁道都拥有相同数量的扇区；每个磁道所包含的扇区数量是一个常数；这个记录区中每个磁道所能包含的扇区数是由最里面的那个磁道所决定的。
    *   每个记录区有着不同的扇区数和磁道数，外层记录区的扇区数和磁道数要比内层的多；
    *   故，我们使用平均值来计算磁盘的容量；

## 磁盘操作（单盘面视角）

磁盘是依靠旋转来进行操作的，因此机械磁盘都有一个很关键的参数叫做「转速」。

## 磁盘访问 - 读取

当处理器需要读取磁盘中的某个数据时，只需要知道扇区和磁道即可访问磁盘中的数据。磁盘中的磁头首先要将磁头放置到存储有目标数据的磁道，然后等待目标数据的扇区转过来即可。

三个因素：移动磁头的时间称为「寻道时间」，等待磁盘旋转的时间称为「硬盘转速」，然后就是数据传输的速度了。

## 磁盘访问时间

*   访问目标扇区的平均时间大约为：
    $$
    T_{access}=Seek+Rotation+Tranformation
    $$

*   寻道时间：一般来说就是 3 - 9 ms 这是一种基本的机械限制，降低基本上是不可能的；

*   平均旋转时间：这个基本上也受到机械原理限制；

*   传输时间：基本上可以忽略不计；

## 逻辑磁盘分区

现代磁盘控制器将磁盘描述为逻辑块，并且提供给处理器进行使用；每个块都是扇区的整数倍；块从 0 开始编号并且递增；

**<u>磁盘控制器保持映射物理扇区和逻辑分区之间的关系</u>** 。这本质上也是一种很高级的抽象；这种抽象可以让控制器保留一些扇区作为备份；以便某些区块坏了之后可以启用这些备份的扇区。这也就是为什么我们看到的磁盘的格式容量要比实际容量要小。因为其中一些扇区是为了容灾而准备的。

PCIE 总线是点对点的。提供 PCI 相同的功能但是更快更高效。

固态硬盘因为分页机制，写操作将变得非常的昂贵。

固态硬盘的速度基本上是传统机械硬盘的 10 倍。

## 固态硬盘 VS 机械硬盘

*   优势：没有机械组件且更快；
*   劣势：
    *   有资源用尽的风险，也就是固态硬盘的颗粒是有寿命的；
    *   在 2015 年，固态硬盘的字节更加昂贵；
*   应用：MP3 播放器，笔记本电脑等等……

总而言之，处理器将不会再是计算机性能的瓶颈，而这个瓶颈将变成数据的传输的访问。因为磁盘和内存访问数据将消耗非常多时间的关系。

## 局部性的拯救

事实证明，弥合处理器和内存之间差距的关键，是这个非常根本的程序的基本属性——程序的局部性。这个是一个程序的持久的，关键的属性。

## 局部性

局部性的原理： **<u>程序使用数据和指令时，倾向于使用那些地址和之前使用过的指令和数据的地址相近或者相等的</u>** 。

也就是说，当一个程序访问了一个地址上的数据之后，这个程序访问附近地址上的指令或者数据的概率将变得很高。

*   临时局部性：当前被引用或者使用的数据项将很可能在未来还被使用；
*   空间局部性：程序会有很高的概率引用临近存储器位置；

## 局部性的例子

```
sum = 0;
for (int i = 0; i < n; ++i) {
	sum += a[i]; /* a[i] 空间局部性：引用附近的元素 */
	/* sum ：临时局部性 */
}
return sum;
```

*   数据的引用
    *   数组元素在每一次迭代中被重复引用；
    *   `sum` 变量也在每一次迭代中被引用；
*   指令的引用
    *   在循环中指令按照序列来引用；

## 定性评估局部性

良好的利用局部性原理的代码将很大的提升程序的性能；

```
int sum_array_rows(int a[M][N])
{
	int sum = 0;
	for (int i = 0; i < M; ++i) {
		for (int j = 0; j < N; ++j) {
			sum += a[i][j];
		}
	}
	return sum;
}
```

以上的程序在内存中，每次访问的元素地址步长都是等于 1 的，这说明代码具有良好的局部性；这是代码最好的撰写方式了。

```
/* 非常糟糕的例子 */
int sum_array_rows(int a[M][N])
{
	int sum = 0;
	for (int j = 0; j < N; ++j) {
		for (int i = 0; j < M; ++i) {
			sum += a[i][j];
		}
	}
	return sum;
}
```

以上的代码将是非常糟糕的例子，迭代的步长居然达到了 N 。

## 内存层级的案例

将快速的存储器作为慢速存储器的高速缓存。

## 缓存

*   缓存：使用一个小的，快速的存储设备来为大的，慢速的存储设备提供阶段性临时存储的行为，就叫做缓存；
*   缓存也是存储层级化的核心概念：对于每个 k ，k 级的存储设备将作为 k + 1 级的设备的缓存；
*   为什么存储层级化能够奏效：
    *   **<u>因为局部性原理</u>** ，程序倾向于访问 k 级存储而非 k + 1 级存储器；如果程序需要某个数据或者指令，它会将其拷贝到 k 级存储器而非继续访问 k + 1 级，从而多次以非常快的速度访问它。
    *   故，k + 1 级存储器将可以以慢速运行。
*   **<u>这就导致了，层级化的存储构造了一个巨大的存储池，这个存储池的大小相当于最底层存储设备的大小，而提供给程序接近于最顶层设备的访问速度</u>** 。

## 通用的缓存概念

缓存是一个非常通用的概念，可以应用于层级化的存储器结构中的任意一层。

当我们要访问的块已经被存储在缓存中了，处理器可以直接从缓存中取用，我们管这个情况叫「缓存命中（ Hit ）」，这是非常理想的情况。但是当未命中（ Miss ）的情况出现了之后，就需要先从存储器中将数据移动到缓存中，然后再从缓存中拿取数据，这将是一个比较慢的过程。

## 通用的缓存概念：缓存未命中的情况分类

*   **<u>冷未命中（强制未命中）</u>** ：这种情况的出现是因为告诉缓存中没有存储任何的数据。冷不命中这种情况是没有办法避免的。而在这种情况下，将数据加载到空的缓存中的行为称为「缓存热身」。

*   **<u>容量未命中</u>** ：因为缓存的大小是有限的，在这种情况下，我们需要更大的缓存才能避免这种不命中的情况发生。如果有更大的缓存就会有良好的命中率。

    我们将一些不断被程序访问的块称为工作集。工作集会随着程序的执行而改变，当工作集产生更替的时候，就会产生容量未命中的情况。

*   **<u>冲突未命中</u>** ：这个和缓存的实现方式有关。具有这个问题的缓存实现将限制一些块的存放方式，比如说某些数据必须存放在什么地方等等。比如说针对特定的数据产生一个 Hash 值，当 Hash 值相同时，缓存就会发生像哈希冲突一样的问题。这种情况就是「冲突未命中」。

    也就是说，虽然有很大的剩余空间，但是存储策略不允许数据存储在其他地方。

## 总结

*   处理器，内存和外部存储设备之间的速度差距依旧在增大；
*   撰写良好的程序具有相当强的「局部性」；
*   层级化的存储架构基于一种叫「缓存」的核心概念，这个技术利用了程序的局部性特点让程序对存储器之间的速度差异不再敏感