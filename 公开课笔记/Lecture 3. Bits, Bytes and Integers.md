# Lecture 3. Bits, Bytes and Integers

## 原码加法

这一节的问题就是，如果将两个以位序列表示的无符号整数相加，产生的结果可能会超出当前数据类型的表示能力，即也许需要多一位的字长来表示结果的数值。但是计算机不可能提供无限的位来进行表示和存储，这时候应当怎么办？

一个常规的办法就是： **<u>将多出来的那一个高位直接悄悄的丢弃</u>** 。

标准的加法函数的办法： **<u>丢弃最高位</u>** 。这个行为相当于给结果做了一次模运算。

```
unsigned 4 bits 0 ---> 15
 1101 ---> 13 +
 0101 ---> 5 == 18
10010 ---> 18 - 16 == 2
 0010 ---> 2
18 % 16 = 2

 1000 ---> 8
 1000 ---> 8
10000 ---> 16 - 16 == 2
16 % 16 == 0
 0000 ---> 0
```

这种情况也被称为发生「环绕」。

## 补码加法

补码加法也是同样，如果产生了进位溢出，那么也是直接 **<u>将多出的最高位直接丢弃</u>** 。

```
1000 ---> -8
0111 --->  7

1101 ---> -3 +
0101 --->  5
=> 10010 Then drop the highest bit
=> 0010 --->  2

0011 --->  3
1011 ---> -5 +
=> 1110 ---> -2
```

以上可以看出，补码和原码对于位序列的计算方式是一样的。

```
 1101 ---> -3
 1010 ---> -6
=> 10111 ---> -9 + 16 /* Add the Umax */
=>  0111 --->  7

0111 ---> 7
0101 ---> 5 +
=> 1100 ---> 12 - 16 /* Subtract the Umax */
=> 1100 ---> -4

0100 ---> 4
0100 ---> 4
1000 ---> 8 - 16 == -8
```

当产生正溢出时，结果将减去 $2^{w}$ ；当产生负溢出时，结果将加上 $2^w$ 。如果单纯要记忆，这个非常好记，就是如果正溢出了，那么就需要减去 `Umax` 把数值拉回到能表示的范围；如果负溢出了，就要加上 `Umax` 同样将数值拉回到可表示的范围。

## 原码 & 补码乘法

所有的计算的核心思想都是相似的： **<u>如果无法在给定的字长中表示这个数值，那么就只取较低的 $w$ 位，高位就会被直接丢弃</u>** 。

乘法的核心思想就是： **<u>如果取两个 $w$ 位的数并将它们相乘，就可能需要一个 $2w$ 字长的数据类型来保存计算结果。但是计算机无法提供这么多的位来记录这个结果数值，那么还是一样，计算机只会保留较低的 $w$ 位，并且将高位直接丢弃</u>** 。

## 原码乘法

* 标准的乘法算法： **<u>丢弃高位，只保存结果的低 $w$ 位</u>** 。
* 实际结果计算公式： $UMulti_{w}(u, v)=(u\cdot v)mod(2^w)$ 。

```
0011 ---> 3
0101 ---> 5 *
0000
 0011
  0000
   0011
=> 0001111 ---> 15
=> 1111 ---> 15

0101 ---> 5
0101 ---> 5 *
0000
 0101
  0000
   0101
=> 0011001 ---> 25 % 16 == 9
=> 1001 ---> 9
```

这就是原码乘法的算法： **<u>不管高位上多出来的是什么，只管丢弃，然后仅仅保存低 $w$ 作为结果，然后以原码方式翻译成数值即可</u>** 。

## C 语言中的补码乘法

* 标准的乘法函数算法：
    * 和原码乘法一样，只保留计算结果位模式的低 $w$ 位作为实际结果。
    * 被保留的低 $w$ 位中的最高位将决定这个实际结果的数值正负。

关于补码乘法的结论就是： **<u>不仅要抛弃多出来的高位，并且剩下的 $w$ 位中的最高位将决定计算结果的正负</u>** 。

```
/* There numbers are represented by two's Complement */
0011 ---> 3
0101 ---> 5 *
0000
 0011
  0000
   0011
=> 0001111 ---> 15
=> 1111 ---> -1 /* Negative Result */

0101 ---> 5
0101 ---> 5 *
0000
 0101
  0000
   0101
=> 0011001 ---> 25
=> 1001 ---> -8 + 1 == -7
```

对于负数的乘法来说也是一样，如果乘法发生了溢出并且计算机丢弃了计算结果的高位导致流失了信息。 **<u>但是数字如果可以用当前字长来表示的话也能得到正确的结果</u>** 。

```
1101 ---> -3 (13)
1110 ---> -2 (14)
 1101
  1101
   1101
    0000
10110110 ---> 13 * 14 == 182
    0110 ---> -3 * -2 == 6 /* Right Answer */
```

**<u>如果数值能被当前数据类型的长度正确表示，哪怕产生了截断，数值也是正确的，无论对于补码还是原码乘法</u>** 。

## 使用位移操作来实现 2 的 $k$ 次方倍

* `u << k` 表示 $u*2^k$ 。
* 以上操作对于原码和补码都是正确的。

将序列左移相当于为每一个位增加了一级基数权重。这个类比十进制就很好理解：

```
00001234 == 1234 << 1
00012340 == 12340 << 1
00123400 == 123400
```

## 使用位移操作来实现整除 2 的 $k$ 次方

* `u >> k` 表示 $u / 2^k$ 并且向下取整。
* 使用逻辑右移（无符号数），也就是用 `0` 填充最高位。

```
0110 ---> 6
0011 ---> 3
0001 ---> 1 /* 3 / 2 = 1.5 ---> 1 */
/* Round towards Zero */
```

即使是在现代计算机上依旧非常缓慢，需要 30 个时钟周期。

```
x ---> -x
0101( 5) ---> 1010 ---> 1011(-5)
1000(-8) ---> 0111 ---> 1000(-8) /* Case of TMin */
```

计算机如何得到一个数的负数：将位模式按位取反之后再加 `1` 。当然对于 `TMin` 来说，这个操作还是会取得本身，这是补码的一个特点，所以我们需要特别关注 `TMin` 。

在 C 语言中，对于补码的位移采用的是算术右移，对于无符号数，采用的是逻辑右移。

## 算术：基本规则

* 加法：
    * 对于无符号/有符号数：采用常规的二进制加法，然后保留当前字长的低位部分；
    * 无符号：算术结果取 $2^w$ 的余数；如果发生溢出，减去 $2^w$ 。
    * 有符号：算术结果取 $2^w$ 的余数；如果产生了正溢出，实际结果等于算术结果减去 $2^w$ ；如果产生的是负溢出，实际结果等于算术结果加上 $2^w$ 。
* 乘法：
    * 对于无符号/有符号数：采用常规的二进制乘法，然后保留当前字长的低位部分；
    * 无符号：算术结果取 $2^w$ 的余数；
    * 有符号：结果是不确定的，因为保留位序列的最高位将决定实际数值的正负。

## 为什么需要使用无符号数？

* 在高清其实现细节之前尽量不要使用

    因为这相当容易出错：

    ```C
    unsigned i;
    for (i = cnt - 2; i >= 0; --i)
        a[i] += a[i + 1];
    /* This loop is a infinite loop 
     * Since unsigned number cannot be negative */
    ```

* 并且可能制造相当难缠的漏洞：

    ```C
    #define DELTA sizeof(int)
    int i;
    for (i = CNT; i - DELTA >= 0; i -= DELTA)
        ...
    /* This loop is infinite loop too
     * Since sizeof returns unsigned number
     * And will convert the i into unsgined number too */
    ```

**<u>尽量不要使用无符号数</u>** 。

## 使用无符号数进行计数

* 使用恰当的方式使用无符号数进行循环：

    ```C
    unsigned i;
    for (i = cnt - 2; i < cnt; --i)
        a[i] += a[i + 1];
    /* Explain: As an example we assign cnt as 3
     * The loop condition will be: i = 1; i < 3; --i
     * i = 1, 0, UnsignedMaxValue
     * When i hit the Umax, the condition will be Umax < cnt
     * Then the loop stops */
    ```

    在这种编码方式下，即使 `cnt` 是一个有符号数，也会被当作无符号数进行解读，并且程序是可以正常运转的。

* 《Secure Coding in C and C++》, Robert Seacord 这本书表示： **<u>C 标准确保无符号数会发生环绕，可以利用这个性质来使用无符号数</u>** ： `0 - 1 == Umax` 。

* 更好地方式（ `unsigned` 只有 32 位，而 `size_t` 有 64 位 ）：

    ```C
    size_t i;
    for (i = cnt - 2; i < cnt; --i)
        a[i] += a[i + 1];
    ```

    * 数据类型 `size_t` 的长度等于计算机的字长；
    * 代码还是会利用上一条的性质来进行循环；

* 当使用模运算的时候使用无符号数。

* 当使用位来作为集合时，使用无符号数。

## 面向字节的内存组织方式

* 程序使用地址来寻找自己需要的数据；
    * 概念上来说，将其视为一个巨大的字节数组；但是实际上并不是这样，但是上面的概念还是可以使用的。
    * 地址就相当于数组的索引，并且这个地址存储在指针类型的变量中。
* 注意：操作系统对每个「进程」提供私有的地址空间；
    * 进程就相当于被执行的程序；
    * 所以，一个程序可以对自己的数据进行操作，但是无法操作别的程序的数据。

当一个程序被运行时，它会认为你有一个很大的内存空间，尽管这并不是真的，并且操作系统只会让它访问一部分的内存，如果它越界访问，就会触发 Segment fault 。

我们将一定数量的字节组织在一起，并且称这一组字节为一个「字」。

## 机器码

**<u>所有给定的计算机都拥有一个「字长」</u>** 。

* **<u>这个字长也就是普通整型数据的长度，当然也是计算机使用内存地址的长度</u>** 。
* 直到最近（ 2015.Fall ），绝大多数机器仍然使用 32 位（ 4 个字节 ）作为机器字长。可以使用的内存是 4GB （ $2^{32}$ 字节 ）。
* 但是， 64 位的机器正在增多。理论上来说，这些机器能使用 18PB 的内存。
* 很多机器仍然支持很多数据格式。

使用 GCC 编译器对 C 语言源文件进行编译，可以选择 64 位还是 32  位。程序支持的位数由机器和编译器共同决定。

现在在很多 64 位机器上， `int` 依然是 32 位的。

## 字节顺序

**<u>所以，几个字节为一个字的话，这个字节应当是如何排列的</u>** ？

以下是几个字节排列的习惯：

* ~~大端法（ Sun ， PPC Mac ， Internet ）：第一个字节是最高位（这个次序也是人书写数字的次序，但是现在的计算机已经抛弃了这个记录方法）~~。
* 小端法（ x86， ARM ）：第一个字节是最低位。

互联网在发包的时候，发送的第一个字节是最高位。

## 字节顺序案例

* 变量 `x` 是一个 32 位数值： `0x01234567` ；
* 第一个地址是 `0x100` ；

```
/* Big Endian */
0x100 0x101 0x102 0x103
01    23    45    67
/*********************/
/* Small Endian */
0x100 0x101 0x102 0x103
67    45    23    01
```

## 整型的表示方法

```
Decimal: 15213
Binary: 0011 1011 0110 1101
Hex:    3    B    6    D
```

```
int A = 15213;

/* IA32, x86-64 - Small Endian */
0x100 0x101 0x102 0x103
6D    3B    00    00
/* Sun - Big Endian */
0x100 0x101 0x102 0x103
00    00    3B    6D
```

```
int B = -15213;

/* IA32, x86-64 */
0x100 0x101 0x102 0x103
93    C4    FF    FF
/* Sun */
0x100 0x101 0x102 0x103
FF    FF    C4    93
```

```
long int C = 15213;

/* IA32 */
0x100 0x101 0x102 0x103
6D    3B    00    00
/* x86-64 */
0x100 0x101 0x102 0x103 ....
6D    3B    00    00    00 00 00 00
/* Sun */
0x100 0x101 0x102 0x103
00    00    3B    6D
```

## 字符串的表示

* C 语言中的字符串：
    * 使用一个字符数组来表示；
    * 每个字符使用 ASCII 码来进行编码；
    * 字符串是以「零字节」来终止的，这被称为 `NULL` 终止符。
* 兼容性：对于字符串来说，不区分字节序列。

**<u>对于数字的兼容性，想要测试极端情况的话， `TMin` 是一个不错的选择</u>** 。

## C 语言的整数习题

```C
/* Initialization */
int x = foo();
int y = bar();
unsigned ux = x;
unsigned uy = y;
```