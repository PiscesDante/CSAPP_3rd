# Lecture 1. Course Overview

## 课程主题：

**<u>抽象是一个好东西，但是别忘了实用性</u>** 。

### 很多计算机和电子的课程注重抽象性

* 抽象的数据类型；
* 渐进分析；

### 这些抽象都是有局限性的

* 特别是在漏洞出现的时候，这种局限性就非常明显；
* 作为一个学生我们需要去理解实现之下的细节部分；

### 上完本课程之后一些有用的结论

* 变成一个更加高效的程序员；
    * 能够更快的找到并且消灭程序中的漏洞；
    * 能够理解并且针对程序的性能进行优化；
* 为了将来的系统性课程做充足的准备；
    * 比如说编译器，操作系统，网络以及计算机架构等等方面；

本课程的核心目的是了解程序是如何运行的，其中的细节是什么。

## 伟大的真相 #1（数字的表示）

**<u>整形不是整数，浮点数是不是实数</u>** 。这个就要理解数字在计算机中是如何表示的。

对于一个整数或者实数的平方，这个结果一定大于零吗？答案分为两种情况：对于浮点型计算来说，一定大于零；但是对于整型来说，结果是不一定的。

```
(gdb) print 40000 * 40000
$1 = 1600000000
(gdb) print 50000 * 50000
$2 = -1794967296
```

```
(gdb) print 300 * 400 * 500 * 600
$4 = 1640261632 --> Wrong
(gdb) print 400 * 500 * 600 * 300
$5 = 1640261632 --> Still wrong, but the outcome is same as before
```

我们可以发现，虽然计算的结果是错的，但是至少在进行了交换之后答案是一样的。

那么对于计算机来说，加法是否遵循结合律？这个问题也分为两个部分：对于有符号以及无符号的整型来说，结果是一定的；但是对于浮点型来说，结果是不一定的。

这里的核心在于，计算机使用有限的位来表示无限的数字，这样的就会存在需要丢弃一些不重要的数字的问题，这种方式就是「舍入」。

## 计算机的算术

### 不要生成随机的值

* 算术操作有一些非常重要的数学性质；

### 不要假定所有的「常规」数学性质是合法的

* 由于计算机表示数字具有「有限性」；
* 整型操作有「环绕」性质；
    * Commutativety, associativity, distributivity ；
* 浮点型操作具有 "Ordering" 性质；
    * Monotonicity, values of signs ；

### 观察

* 需要理解上下文中应用了那些抽象；
* 一些对于严格程序的作者以及编译器作者的重要关注点；

## 伟大的真相 #2（机器级编程）

**<u>我们需要去理解一些汇编语言</u>** 。

* 虽然我们也许永远不会使用汇编语言来写程序，毕竟编译器要比我们更加优秀和有耐心。
* 但是：理解汇编语言对于掌握机器级编程的执行模型非常重要；
    * 当程序出现漏洞时程序的可能表现：高级语言可能会崩溃；
    * 调教程序的性能：理解编译器做或者没做的一些优化；理解程序没有效率的根源所在；
    * 实现系统软件：编译器生成的是机器码；操作系统必须管理进程状态；
    * 创造或者对抗恶意程序： 可选 x86 汇编语言！

## 伟大的真相 #3（内存管理）

**<u>随机访问记忆体（ RAM, 也就是内存）是一个非物理的抽象概念</u>** 。

* 内存是有限的：所以内存必须被良好的分配和管理；内存影响着很多的程序；
* 内存引用的漏洞往往是最有害的：内存引用漏洞对于时间和空间的影响都是深远的；
* 内存的性能不是一样的：高速缓存和虚拟内存会极大的影响程序的性能（很多程序如果不能良好的使用分层的内存可能会导致性能问题）；使程序适应内存的特点会极大的提升程序的速度。

### 内存引用的典型漏洞案例

```C
typedef struct {
    int a[2];
    double d;
} struct_t;

double fun(int i) {
    volatile struct_t s;
    s.d = 3.14;
    s.a[i] = 1073741824; /* Possibly out of bounds */
    return s.d;
}
```

这个程序的返回结果将取决于系统的实际情况。以上的程序错误的核心是内存的组织结构导致的。当访问越界的时候，会接着访问旁边的内存字节，虽然这部分根本就不是原本的数组的一部分。当访问到无法访问的内存区块时，程序就很有可能奔溃。

### 内存引用错误

* C 和 C++ 不提供任何的内存保护措施：比方说内存的越界访问，非法的指针，动态内存分配的滥用，一概全凭程序员自己管理和操作；
* 而这些行为可能导致很难修复的漏洞：最困难的问题就是找出内存引用上的错误。
* 如何处理：不要使用 C 或者 C++ 编程；理解可能会发生地问题；使用开发工具来监测引用错误；

## 伟大的真相 #4（性能优化）

**<u>除了渐进复杂度之外还有很多需要关注的问题</u>** 。

* 在复杂度的量化中，常数项也是很关键的；
* 即便得知确切的操作也无法准确判断实际性能：就连很简单的循环也要考虑代码是如何编写的。编码上的区别会造成性能上的差异；
* 必须从若干个维度上来对程序进行优化：算法，数据表示，过程和循环。
* 必须在理解操作系统的基础上来对程序进行优化
    * 程序是如何编译以及执行的；
    * 如何量化程序的性能以及定位瓶颈部分；
    * 如何在不破坏代码的模块性以及通用性的前提下提升程序的性能；

### 内存系统的性能差异案例

```C
void copyij(int src[2048][2048], int dst[2048][2048])
{
    int i, j;
    for (i = 0; i < 2048; ++i) {
        for (j = 0; j < 2048; ++j) {
            dst[i][j] = src[i][j];
        }
    }
}

void copyij(int src[2048][2048], int dst[2048][2048])
{
    int i, j;
    for (j = 0; j < 2048; ++j) {
        for (i = 0; i < 2048; ++i) {
            dst[i][j] = src[i][j];
        }
    }
}
```

虽然上述程序做的工作是一模一样的，但是性能上可以有 20 倍的差距。这个差距和内存层次结构中的缓存有关。

## 伟大的真相 #5（网络与通信）

**<u>计算机不仅仅是在执行程序</u>** 。

* **<u>它们还在进行数据的交换</u>** ： I/O 系统对于一个程序的性能表现同样非常重要；
* 它们还通过网络进行彼此之间的数据交换：很多系统层面的问题会在网络上表现出来
    * 若干个独立进程的并行操作；
    * 从非可靠的媒体拷贝数据；
    * 跨平台的兼容性问题；
    * 更多复杂的性能问题。

## 课程的教学角度

**<u>很多操作系统的课程都是以操作系统作者为中心的</u>** 。比如说实现特定的功能，如何设计操作系统的架构等等。

但是我们这门课采用程序员的视角来介绍操作系统。也就是说让程序员知道，当需要实现一个功能时，需要对系统有哪些了解。

## 程序和数据

### 课程话题

* 位操作，算术，汇编语言程序；
* C 语言流程控制以及数据结构的展示；
* 包括体系结构的部分以及编译器；

### 作业

* 实验 #1 （ Data Lab ） ：对位进行操作；
* 实验 #2 （ Bomb Lab ） ： 拆除一个二进制的「炸弹」；这个实验要使用 GDB 来进行，否则不太可能能完成。
* 实验 #3 （ Attack Lab ） ： 代码注入攻击的基础；

## 层次化内存

### 课程话题

* 存储技术，内存层级，高速缓存，磁盘，区块；
* 包含计算机体系结构以及操作系统的方面；

### 作业

* 实验 #4 （ Cache Lab ） ： 搭建一个高速缓存模拟器并且为其寻址作出优化。

## 异常控制流

### 课程话题

* 硬件级别的异常，过程，过程控制， Unix 信号， 跳转；

### 作业

* 实验 #5 （ TSH Lab ） ： 撰写你自己的 Unix Shell 。这也是第一个关于并行的介绍。

## 虚拟内存

### 课程话题

* 虚拟内存，地址转换，动态存储分配；

### 作业

* 实验 #6 （ Malloc Lab ） ： 撰写自己的内存分配函数。真正体验一下系统级的编程。

## 网络，以及并行

### 课程话题

* 高级以及低级的 I/O ，网络编程；
* 因特网服务， Web 服务；
* 并行，并发服务器设计，线程；
* I/O 多路复用技术（后面这个 Select 应该是一种技术）；

### 作业

* 实验 #7 （Proxy Lab） ： 撰写自己的网页代理：学习如何进行网络编程以及并行和同步的更多技巧。

