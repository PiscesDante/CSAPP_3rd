# Lecture 16. System Level I/O



## UNIX IO 概览

**<u>一个 Linux 文件本质上是一个字节序列</u>** 。

**<u>对于文件在设备上的优雅的组织方式允许内核提供简单地 Unix IO 接口</u>** ：

*   打开或者关闭文件： `open()` 和 `close()` ；
*   读取或者写入文件： `read()` 和 `write()` ；
*   改变当前文件的光标位置，也就是重新设置文件开始读取或者写入的字节偏移量： `lseek()` 。

总之，可以将文件的打开位置，当作与打开文件相关联的数据的一部分。记录了文件已经读或者写到的位置。

## 文件类型

**<u>关于文件的说法，本质上是我们把很多不同的事物统一抽象成了文件。每个文件都有一个特定的类型来表明其在系统中的角色</u>** 。

*   普通文件：保存任意的数据；
*   目录文件：保存文件的关联组或者索引；
*   套接字文件（通信接口文件）：负责和其他进程或者机器的通信；

**<u>其他的一些超出我们课程范围的文件类型</u>** ：

*   ……

## 普通文件

*   **<u>一个普通文件包含任意的数据</u>** ；
*   应用程序一般只区分文本文件和二进制文件：
    *   文本文件中只包哈 ASCII 字符或者 Unicode 字符；
    *   二进制文件就是除了文本文件的所有其他文件，例如对象文件和图像文件；
    *   操作系统内核并不知道这两者的区别；
*   文本文件是一个文本行的序列；
    *   文本行是一个以换行符 `'\n'` 结尾的字符序列；
    *   新行符的 ASCII 码是 `0xA` ；
*   其他系统中的换行符
    *   Linux & MacOS ：`'\n'` ；
    *   Windows 和 因特网协议： `'\r\n'` ；

Windows 系统中需要两个字符，因为一个是「回车」，一个是「换行」，这个习惯是来源于最早的机械打字机，当打字机需要换行的时候，第一步是将打字的滚筒推回行首，这个步骤就是所谓的「回车」，但是光回车了之后还是不行，因为打字机还是在我们已经输入的最新一行。这时就需要我们的第二步，也就是所谓的真正意义上的「换行」。

## 目录文件

**<u>目录被当作一种文件进行存储</u>** 。

每个目录都含有两个特殊的条目： `.` 和 `..` ；分别表示当前目录自身，和树形结构中当前目录的父目录；

## 路径名称

**<u>在层级目录文件中定位一个文件的方式就是使用「路径名称」，路径名称有两种形式，绝对路径和相对路径</u>** ：

*   绝对路径名称以 `'/'` 开头并且从 `root` 也就是根目录开始：

    ```
    /home/Documents/hello.c
    ```

*   相对路径名称以当前目录作为基准开始：

    ```
    ../home/Documents/hello.c
    ```

## 打开文件

打开文件的操作会通知系统内核当前进程需要访问目标文件：

```C
int file_descriptor;
/* 打开一个文件需要文件路径，和打开方式（只读，只写等等……） */
if ((file_descriptor = open("/etc/hosts", O_RDONLY)) == -1) {
    perror("OPEN ERROR");
    exit(1);
} else {
    /* FILE IS OPENED... */
}
```

`open()` 函数会返回一个文件描述符，反应当前文件打开的状态：若 `file_descriptor == -1` 则说明打开文件的操作遇到了错误。

**<u>每一个使用 Linux Shell 创建的进程都有三个特定的文件描述符</u>** ：

*   0 ：标准输入 `stdin` ；
*   1 ：标准输出 `stdout` ；
*   2 ：标准错误 `stderr` ；

## 关闭文件

**<u>关闭文件操作会通知系统内核已经结束对文件的访问</u>** 。

```C
int file_descriptor;
int return_value;

if ((return_value = close(file_descriptor)) < 0) {
    perror("CLOSE ERROR");
    exit(1);
}
```

*   关闭已经关闭的文件可能会造成很大的麻烦，尤其是在多线程的程序中（多线程的操作都不是原子的，数据可能都是共享的，一个线程可能会尝试关闭已经关闭的文件）；
*   建议：总是检查文件操作的返回值，哪怕是像关闭文件这样的普通操作；

## 读取文件

**<u>读取文件的操作是将当前文件光标处的字节拷贝到内存中，然后更新文件光标</u>** 。

```C
#define CACHE_LENGTH 512

char reading_cache[CACHE_LENGTH];
int file_descriptor;
int reading_bytes_amount;

/* OPEN FILE AND GET FILE_DESCRIPTOR
 * THEN READ UP TO CACHE_LENGTH BYTES FROM FILE... */

/* read(文件描述符, 读取缓存, 缓存容量) */
if ((reading_bytes_amount = read(file_descriptor, reading_cache, CACHE_LENGTH)) < 0) {
    perror("READ ERROR");
    exit(1);
}
```

`read` 函数的返回值如果等于零说明已经读取到了文件的末尾，或者文件已经被整体读取完成；如果是一个正数，那么就表示该次读入的字节数；如果是一个负数，就说明文件读取错误；

## 写入文件

**<u>写入文件是将内存中的字节写入到目标文件的光标处，然后更新文件光标</u>** 。

```C
char writing_cache[CACHE_LENGTH];
int file_descriptor;
int writing_bytes_amount;

// ...

writing_bytes_amount =
    write(file_descriptor, writing_cache, CACHE_LENGTH);
if (writing_bytes_amount < 0) {
    perror("WRITE ERROR");
    exit(1);
} else {
    ... /* 正常写入的情况 */
}
```

## 不足值的情况

不足值情况就是读取或者写入的字符数量比缓冲区长度要少；

**<u>不足值会在以下三种情况下出现</u>** ：

*   在读取时遭遇到 EOF 文件结束符；
*   从一个终端中读取字符；
*   对网络套接字进行读写；

**<u>不足值在以下几种情况中不会出现</u>** ：

*   从磁盘中读取（除非碰到 EOF）；
*   向磁盘中写入；

**<u>建议：在任何情况下都允许不足值的出现</u>** ；

一般情况下， 通过互联网发送的数据包的大小是 1000 个字节，但是实际取决于是哪一层协议的数据包，但是一般是 1500 个字节，这就是标准的「最小传输单元」；

## 文件元数据

*   元数据指的是关于数据的数据，在当前语境下，我们指的是关于文件本身的数据；比方说文件的创建时间，访问时间，修改时间等等……
*   每个文件的元数据是由操作系统内核来维护的；

## Unix 内核如何表示一个打开的文件★

>   这个部分将非常难懂，推荐仔细研究课本和习题。

两个文件描述符可以打开并且指向两个完全不同的文件，例如描述符 1 指向终端，描述符 4 指向一个磁盘文件；

## 文件共享

这个地方讲的意思大概是，两个不同的文件描述符可以指向同一个文件并且对这个文件进行读写操作；

虽然通过若干个文件描述符来同时读一个文件不会有什么大问题，但是一旦涉及写入，可能会让文件内容混乱不堪。

## 进程如何共享文件： `fork`

**<u>一个子进程会继承其父进程的已经打开的文件</u>** 。

在调用 `fork` 函数之后，子进程会有一个和父进程相同的「文件描述符表」，通过这个表，子进程可以像父进程一样来访问被父进程已经打开的文件。并且在「打开文件表」中的引用量会增加 1 。

## I/O 重定向

问题：Shell 如何实现输入输出重定向？

```
linux> ls > foo.txt
```

这个方法在 Windows 上的 PowerShell 中也可以使用。

答案：可以调用 `dup2(old_file_descriptor, new_file_descriptor)` 。这个函数的作用就是将旧的输出替换为新的输出：

```
dup2(4, 1); ===> file_descriptor_1 = file_descriptor_4
```

## 标准输入输出函数

**<u>C 语言标准库包含一系列的高层标准输入输出函数</u>** ：

```
打开或者关闭文件：fopen() & fclose()
读写文件：fread() & fwrite()
读写文本文件中的文本行：fgets() & fputs()
格式化读 & 格式化写：fscanf() & fprintf()
```

## 标准输入输出中的缓冲机制

**<u>创建缓冲区，先将数据写入缓冲区，然后调用 `fflush`</u>** 。

## 选择 I/O 函数

**<u>通用法则：尽可能的使用最高级的输入输出函数</u>** 。

## 注：对于二进制文件

**<u>以上标准输入输出函数不能被使用于读写二进制文件</u>** 。

## 更多信息

Linux 圣经： **<u>Linux/UNIX系统编程手册</u>** 。