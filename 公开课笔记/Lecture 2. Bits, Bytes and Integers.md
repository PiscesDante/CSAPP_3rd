# Lecture 2. Bits, Bytes and Integers

这一讲的主题就是 **<u>位，由8位为一个单位的字节，以及整数</u>** 。浮点数在这一讲中并不涉及。

## 一切都是位

* 每个位都是 `1` 或者 `0` 。
* 计算机所做的就是编码或者翻译一组位，来获取获取不同的信息；
    * 计算机做事遵循一定的规则（指令）；
    * ……以及操作和表示数字，集合以及字符串等等；
* 为什么是「位」？位是电气信号的数字形式
    * 位非常容易进行存储；
    * 在传输过程中展现出极大的抗干扰能力，能够在差劲的电线中进行传递；

**<u>在电气信号中，我们可以使用 1.1 V 左右的电压来代表 `1` ，使用 0.2 V 及以下的电压代表 `0` ，通过对时间域进行采样我们就能够获得一组位序列</u>** 。只要电压在这个范围之内，我们还是能得到确定的信号。

**<u>存储一组数字序列要比存储一组模拟信号要简单地多</u>** 。

## 举个例子，我们能使用二进制来计数

### 以 2 为进制的数字表示法

```
15213(10) ---> 11101101101101(2)
1.20(10) ---> 1.0011001100110011[0011]...(2)
```

## 编码以位来表示的值

**<u>1 字节（ Byte ） = 8 位（ Bit ）</u>** 。

```
00000000(2) ---> 11111111(2)
0(10) ---> 255(10)
00(16) ---> FF(16)
```

## 数据表示的一部分案例

这里要注意一下，哪怕在 64 位的机器上， `float` 也是 `4` 位的，只有 `double` 会是 `8` 位的。

## 布尔代数

由 George Boole 在 19 世纪创造，这也是首次尝试将逻辑代数化的举动，也就是将「真」编码为 `1` ，「假」编码为 `0` 的代数学。

这里唯一要注意的是「异或」这个概念，其定义为 **<u>异为真，同为假</u>** 。

## 案例：表示以及计算集合

### 如何表示一个集合

```
a_j = 1 if j included in A = { 7, 6, 5, 4, 3, 2, 1, 0 }

01101001 ---> { 0, 3, 5, 6 }
76543210

01010101 ---> { 0, 2, 4, 6 }
76543210
```

### 如何使用布尔代数计算一个集合

```
&
01101001
01010101 ---> 01000001
              76543210 ---> { 0, 6 }
              
|
01101001
01010101 ---> 01111101
              76543210 ---> { 0, 2, 3, 4, 5, 6 }

^
01101001 /* symetric differerce */
01010101 ---> 00111100
              76543210 ---> { 2, 3, 4, 5 }

~
01101001 ---> 10010110
              76543210 ---> { 1, 2, 4, 7 }
```

## C 语言中的位操作符

以上布尔代数中的符号在 C 语言中也是可以使用的。

* 对所有的内置类型都是可以使用这些位操作符；
* 位级操作将数据看作是位向量进行操作；
* 参数都是可以作为位来操作；

```
~0x41 ---> 0xBE
~01000001b ---> 10111110b

~0x00 ---> 0xFF
~00000000b ---> 11111111b

0x69 & 0x55 ---> 0x41
01101001b & 01010101b ---> 01000001b
```

## 对比： C 语言中的逻辑操作符

```
!0x41 ---> 0x00 /* simple false and true */
!0x00 ---> 0x01 /* not about the bits */
```

逻辑操作符是真对数字本身，而不是针对数字的二进制位序列进行操作。当逻辑操作符认为是「真」时，它只会返回值 `1` 。

## 位移操作

### 左移操作： `x << y`

**<u>将位序列 `x` 向左移动 `y` 个位置，这个操作将单纯丢弃左边的位，然后用 `0` 填补右边的空位</u>** 。

```
argument x : 01100010
<< 3       : 00010000
```

### 右移操作： `x >> y`

**<u>将位序列 `x` 向右移动 `y` 个位置</u>** 。这个操作有两个版本：

1. 逻辑右移：丢弃右边的位，然后左边用 `0` 补齐；
2. 算术右移：丢弃右边的位，然后左边用「最高位」补齐；算术右移通常是针对有符号类型，因为算术右移的特点就是会保留数字的最高符号位，从而保证右移之后值不变。

```
argument x : 10100010
<< 3       : 00010000
Log. >> 2  : 00101000
Arh. >> 2  : 11101000
```

### 未定义行为

**<u>进行负数位移或者进行超出数据类型本身位长度的位移</u>** 。

## 对整数进行编码

对于无符号的整数来说，从位序列进行求值的公式如下：
$$
B2U = \sum_{i=0}^{w-1}x_{i}2^{i}
$$
对于有符号整数来说，从位序列进行求值的公式如下：
$$
B2T = -x_{w-1}2^{w-1} + \sum_{i=0}^{w-2}x_{i}2^{i}
$$
从这两个核心公式可以看出：对于无符号整数，直接将按位进行加权后求和即可；但是对于补码表示的有符号整数，最左边的那一位被称为「符号位」，而这个符号位的权重是负的。

### 以 C 语言中的 `short` 类型拥有两个字节长度为例

```
x  15213 -> 0x3B6D -> 00111011 01101101
y -15213 -> 0xC493 -> 11000100 10010011
```

有符号整数是以补码的方式来记录，无符号整数是以原码的方式来记录，两种编码方式必须套用不同的转换公式才能得到正确的位序列以及位序列所表示的值。

### 符号位

对于 `Two's Complement` ，也就是补码表示法，最核心的位就是这个用来表示数字正负的「符号位」：

* `0` 表示数字「非负」；注意是「非负」，因为在补码的系统中 `0` 的符号位也是 `0` ；
* `1` 表示数字为「负」，当符号位为 `1` 时，负权是被激活的；

## 数字范围

* 对于原码表示的无符号整数（以 4 位来举例）：
    * 最小值 `Umin` 为 0 ；位模式： `0000` ；
    * 最大值 `Umax` 为 15 ；位模式： `1111` ；
* 对于补码表示的有符号整数来说（以 4 位来举例）：
    * 最小值 `Tmin` 为 -8 ；位模式： `1000` ；
    * 最大值 `Tmax` 为 7 ；位模式： `0111` ；

结论： **<u>对于原码表示的无符号整数来说，最小值就是将所有的位全部置 `0` ，得到的最小值就是 0 ；最大值就是将所有的位全部置 `1` ，得到的最大值就是所有位的加权和。对于补码表示的有符号整数来说，最小值就是将符号位置 `1` ，其余位全部置 `0` ；最大值就是将符号位置 `0` ，其余所有位置 `1`</u>** 。

## 无符号 & 有符号数值

* 等价区间：无符号整数和有符号整数在值为非负的时候编码方式是一样的；
* 唯一性：每个位模式表示一个唯一的值；并且每个值都能被唯一的进行编码；
* 数字位序列和数字值之间可以映射并且转换。

原码和补码只是解释位序列的方式，一串位模式通过这两种编码方式进行解释之后可能会得到两个不同的值。而且，核心的变化就是在于「符号位」的权重上，原码中，最高位的权重是正的，而在补码中，最高位的权重是负的。

## C 语言中的无符号 & 有符号整数

### 常数

在 C 语言中，常数被默认为有符号数，并且以补码的形式编码存储；如果程序员想要将其作为无符号整数，则必须加上 `U` 这个后缀： `1024U` 。

### 转换

* 显式转换：

    ```C
    int tx, ty;
    unsigned ux, uy;
    tx = (int) ux;
    uy = (unsigned) ty;
    ```

* 隐式转换：

    ```C
    tx = ux;
    uy = ty;
    ```

## 隐秘的转换

**<u>`signed` values implicitly cast to `unsigned`</u>** 。

**<u>当一个有符号数和一个无符号数进行比较或者运算的时候，计算机会首先将它们隐式的转换成为相同的类型，然后再进行计算</u>** 。

规则是： **<u>如果其中一个数字是无符号数，那么计算机会首先将另外一个有符号数转换成无符号数，然后再进行计算</u>** 。

这里虽然我们叫做「转换」，但是实际上并没有做值的转换，而是 **<u>使用无符号的编码规则去解释有符号数的位序列</u>** 。

```
-1 > 0U :
	/* Procedure of calculation: */
	1. 1111 > 0000 ? --->
	2. 1111 ---> 1 + 2 + 4 + 8 == 15
	3. 15U > 0U ? ---> TRUE;
/* So (-1 > 0U) returns TRUE, but it is wrong */

2147483647U < -2147483647-1 :
	/* Procedure of calculation: */
	1. -2147483647-1 is Tmin,so the bitpattern is 100...00
	2. 2147483647U's bitpattern is 011...11
	3. 011...11 < 100...00 ? ---> TRUE
/* So (2147483647U < -2147483647-1) returns TRUE */
```

## 总结：有符号 & 无符号之间的转换规则

* **<u>底层的位序列是不变的</u>** ；
* **<u>转换仅仅是变更对这个位序列的解释方式</u>** ；
* 转换期间可能会有意料之外的事情发生：加上或者减去 $2^{w}$ 。
* **<u>如果一个表达式中既包含有符号数同时也包含无符号数，那么有符号数的位序列将会被以无符号数的方式进行解释，并且以解释后的值进行计算</u>** 。

```C
/* What if x is TMin? */
if (x < 0) {
    return -x; /* Still return TMin */
}
```

```
Tmax = 01111...11
If we treat it as unsgined:
2 * Tmax = 11111...10
So the bitpattern comes out that:
Umax = 2 * Tmax + 1
```

如果进行以下的程序：

```C
unsigned i;
for (i = n - 1; i >= 0; ++i) {
    call_func(); ...
}
```

该循环是个无限循环，因为 `i` 是个无符号数的关系，所以 `i` 永远不会小于零。

 或者若有以下的循环：

```C
int i;
for (i = n - 1; i - sizeof(char) >= 0; ++i) {
    ...
}
```

这个循环还是一个无限循环，因为 `sizeof` 操作符返回的是一个无符号数。这个无符号数会将表达式中的所有有符号数的位序列当作无符号数来解读，导致一个无符号数永远会大于零，这个循环也就会无限循环下去。

## 符号扩展

### 任务

* 给定一个 $w$ 位的有符号整数 `x` ；
* 将其转换成 $w+k$ 位的整数。

### 规则

* 将符号位复制 $k$ 个：
* $X'=x_{w-1},x_{w-1},x_{w-1},...,x_{w-2},...,x_{0}$ 。
* 这种扩展的方式被称为「符号扩展」，这种方式的作用是 **<u>对于有符号整数，在不改变其值的情况下将其转换成为位数更多的类型</u>** 。

## 截断



## 总结：扩展以及截断的基本原则

* 扩展的原则（ 比如 `short int` 扩展为 `int` ）
    * 无符号数：在左侧加上足够多的 `0` 即可。
    * 有符号数：在左侧加上足够多的「符号位」即可。
    * 两者都会得到同一开始相同的数值。
* 截断的原则（ 比如 `unsigned` 截断为 `unsigned short` ）
    * 有符号以及无符号：直接丢掉左侧的位即可；
    * 然后重新解释剩下的位；
    * 无符号整数：进行模运算；
    * 有符号整数：类似模运算；
    * 对于小数字来说，会得到相同的数值。如果短类型的位数能够表示这个数值的话。
